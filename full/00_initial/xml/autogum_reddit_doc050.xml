<text id="autogum_reddit_doc050" title="Q: How should C++ support persistent memory?" shortTile="q-c-support-persistent" author="Reddit community (see URL)" type="reddit" dateCollected="2019-11-02" dateCreated="2018-05-31" dateModified="2018-05-31" sourceURL="http://redd.it/8ni6p4" speakerList="#14ned, #OldWolf2" speakerCount="2">
<head>Q: How should C++ support persistent memory?</head>
<sp who="#14ned">
<p>Optane DDR4 DIMMs have been announced (https://www.anandtech.com/show/12828/intel-launches-optane-dimms-up-to-512gb-apache-pass-is-here). These fit into your RAM slots, and on supporting motherboards (i.e. none of the current ones), they can be configured in the BIOS to appear either as a hard drive, or as RAM, to your system. Next year's motherboards which support PRAM DIMMs should have sufficient slots for fitting up to 64Tb (yes, terabytes) of DIMMs, though these will probably be server motherboards. Despite some of the misinformation currently going around, Optane DIMMs have a similar read latency to normal DDR4 RAM, but about double the write latency. Bandwidth is similar to DDR4 RAM i.e. lots. Unlike DRAM, PRAM does not require constant DRAM refreshes, and thus is especially attractive to power conserving devices such as laptops and mobile phones. The dollars per Gb ratio is dropping faster than any other type of storage currently, as if trends continue, they will match the capacity per dollar of flash storage around this time next year (see Figure 1 in http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1026r0.pdf). Persisting data to these DIMMs is as straightforward as telling your CPU to flush modified cache lines to main memory. On current Intel CPUs, this is inefficient as one must also evict those lines from the cache, but on all recent ARM CPUs and on Ice Lake Intel CPUs onwards, one can flush modified cache lines without eviction. So, given that we're about a year out from these things appearing in commodity (if likely premium) hardware, how would /r/cpp like to see C++ support persistent memory? Some options: 1. Do nothing, see how things are in a few years from now. 2. Intel's persistent memory library (http://pmem.io/pmdk/) will be sufficient. 3. Intel's persistent memory library is too alien, we need something more STLish. 4. We need this support immediately! Refactor the C++ 23 standard to directly support persistent memory (understanding that this will slip the release date considerably later than 2023) Disclaimer: I'm the guy presenting P1026  <hi rend="bold">A call for a Data Persistence (iostream v2) study group</hi>  to WG21 LEWG this Wednesday morning coming, and I am absolutely canvassing for what kind of feelings the C++ userbase have regarding support for persistent memory. WG21 will likely prefer option 1 above, but if the C++ community were feeling very strongly about option 4 ... :) Anyway, this is your chance to get feedback to the C++ standards committee, and maybe help guide a decision. Many thanks in advance for your time and feedback. http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1026r0.pdf </p>
</sp>
<sp who="#OldWolf2">
<p>Non-volatile RAM is nothing new, one of the first C embedded systems I worked on had only NVRAM , which was used for working memory as well as storage. Incidentally the manufacturer collapsed because they couldn't compete on price with other devices that used a mix of cheap RAM and Flash. </p>
<p>I don't recall the exact details now, but I think the way the OS set up was that certain address ranges would be marked as don't reset on startup , and we could assign variables to that address range via a source code extension. Then we could either just work directly in those variables, or (to support adding struct members in future). memcpy in and out of it with some primitive serialization. </p>
<p>I'm sure people can come up with much better idioms nowdays though :) </p>
</sp>
</text>
