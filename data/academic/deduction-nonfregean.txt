 1. IntroductionOne of the tasks of formal logic is to provide adequate tools for the formal analysis of certain fragments of natural language, as well as for the languages of particular fields of science. It is commonly accepted that the theory of interpretation of a language is semantics. The choice of semantics determines how we think about a given language and what meaning we assign to its components. It is often acknowledged that the first precisely formulated semantic principles—that serves as a foundation for contemporary formal logic and have determined its development—were presented by Frege in his Begriffsschrift. According to Frege, a correct and adequate formal system of a given language should meet the following conditions:F1 All names and all sentences have meaning and denotation. Meaning is not the same as denotation.F2 A name and a sentence are the proper names of their denotations.F3 Only one logical value can be assigned to each sentence: true or false.F4 If two expressions have the same denotation, then they are exchangeable in any propositional context of a sentence without changing the logical value of that sentence.F5 If two sentences are exchangeable in any propositional context of a sentence without changing its logical value, then they have the same denotation.Note that crucial notions for Frege’s account are the following: meaning, denotation, and logical valuation. Frege admits that the meaning of a sentence is not the same as its denotation. Indeed, the same holds for names: ‘Evening Star’ and ‘Morning Star’ denote the same object, but they have different meanings. The meaning of a sentence should be understood as its sense that the sentence expresses. Thus, we should ask what a sentence is referring to. From the formal point of view, the answer to this question requires, in particular, to decide what the denotation of a propositional variable is.Propositional variables have an unusual character due to the fact that, at the same time, they are formulas. In classical logic, this ambiguity is removed as it identifies denotations of sentences with their truth values. In other words, in classical logic, propositional variables occur only at the metalogical level (they are not treated as real variables) or, as it holds in propositional calculus, variables range over the two element set of logical values. Within such an account, only terms have a meaningful ontological reference. Thus, the advocate of classical logic, if he is also a proponent of the Fregean semantic principles, must accept that all true sentences have one and the same denotation, namely the logical value
Truth
, and denotation of all false sentences is the logical value
False
.The consequence of Frege’s semantic principles, according to which denotations of sentences are logical values, is usually called the Fregean principle, and every logical system that adopts this principle is called a Fregean system. The Fregean approach can be considered as philosophically justified in the study of mathematical languages, but it is not obvious that such an approach is justified as a foundation of a philosophically adequate semantics. The debatable cases of the applicability of the Fregean account in the formalization of any language are, for instance, theories of meaning or ontology. If we admit that the references of sentences are situations (states of affairs) that these sentences describe (in analogy with the assumption that the semantic references of terms are objects named by these terms), then the Fregean principle is not only a semantic principle, but also an ontological one which imposes a quantitative restriction on the universe of situations: there are at most two situations described by sentences. This is an extremely strong assumption. Note that the Fregean account does not impose an upper limit on the universe of objects.Roman Suszko in 1968 [1] proposed to change the Fregean paradigm and introduced the so-called non-Fregean logic (see also [2]). The basic philosophical assumption underlying non-Fregean logic is the thesis in reality to which the language is referring, and there exist semantic correlates of all expressions that are not purely syntactic. Therefore, in the non-Fregean approach, it is assumed that the semantic correlates of names are objects from the universe of objects, the semantic correlates of predicates are appropriate sets, and the semantic correlates of sentences are situations described by these sentences. Furthermore, a universe of situations cannot be quantitatively restricted, except that there are at least two situations.The construction of a propositional non-Fregean logic, which at the same time preserves all properties of classical logic with respect to the classical connectives, is relatively simple. To make it possible to express statements on situations and interactions between them, propositional calculus is extended with the additional connective, named the identity connective and denoted by ≡. The intended interpretation of the identity connective is the following:

ϕ
≡
ψ

 is true if and only if the semantic correlates of
ϕ
 and
ψ
 are the same, that is, sentences
φ
 and
ψ
 describe the same situation (the same state of affairs). Note that, in a general case, the identity connective is different than the classical equivalence. Equivalent sentences, that is, sentences that do not have the same logical value, do not have to refer to the same situation, and so they do not have to be identical. In other words, the logical value of a sentence and the situation described by this sentence are two different things.Suszko states that the identity connective is more primitive than other non-truth functional connectives such as modal connectives of possibility and necessity. The identity connective is more primitive in the sense that it cannot be eliminated without identifying it with the equivalence connective. However, if we add the identity connective to classical logic, we do not lose two-valuedness. If a non-Fregean system of logic would be constructed based on classical logic, extending its language with the identity connective and constructing semantics in which classical connectives preserve their classical meaning, we will obtain a two-valued system, in which each sentence is either true or false. On the other hand, being logically two-valued, non-Fregean logics can be seen as systems that are ontologically (referentially) many-valued.The weakest extensional and two-valued propositional non-Fregean logic is
SCI
 (Sentential Calculus with Identity). A detailed description of the philosophical assumptions of
SCI
 can be found in [2]. Originally, logic
SCI
 was defined as an extension of classical propositional logic with four axioms expressing the following properties of the identity connective: (1) any sentence is identical with itself, (2) if two sentences are identical, then so are their negations, (3) identical sentences are equivalent, and (4) sentences that are identical are interchangeable in any propositional context. A sound and complete semantics for
SCI
 was designed by Suszko and Bloom in [3]. A models for
SCI
 is a structure that consists of a universe of situations, a distinguished subset of facts (situations that actually hold), and operations that represent all the connectives. Furthermore, it is assumed that the operations satisfy certain conditions with respect to the distinguished set of situations so that the classical connectives gain their classical meaning, and the operation corresponding to the identity connective represents the identity between situations. For details, see Section 2.It is established that
SCI
 has the finite model property and is decidable. Moreover, as shown in [4], the class of different axiomatic extensions of
SCI
 is uncountable. There is also some research on non-standard (deviant) modifications of
SCI
 obtained by rejecting some of its fundamental assumptions or extending its language with additional operators. Recently, the most studied modifications of
SCI
 are Grzegorczyk’s non-Fregean logics, which are paraconsistent non-Fregean logics ([5,6,7]). Some research has been also focused on first-order non-Fregean logics, in particular

SCI
Q

. In [8], it has been proved that the logic

SCI
Q

, obtained by extending
SCI
 with propositional quantifiers, is able to express infiniteness and many well-known mathematical theories (e.g., the theories of groups and fields, Peano arithmetic). Furthermore,

SCI
Q

 does not have the finite model property, is undecidable, satisfies the Löwenheim-Skolem Theorem, and is an analog of Fagin’s Theorem (the class of sets of natural numbers that are expressible in

SCI
Q

 is precisely the complexity class
NP
).The non-Fregean approach has many philosophical and logical advantages as it offers a relatively simple, natural and intuitive basis for exploring fundamental relationships between language and situations. Moreover, non-Fregean logics can be seen as a general framework for representing and comparing logics with different languages or semantics. Indeed, it turned out that many non-classical logics can be equivalently translated into some extensions of
SCI
. For instance, modal logics

S
3

,

S
4

, and

S
5

 are equivalent to some extensions of
SCI
, that is, there are translations—from a non-Fregean language to a modal one and the other way round—that preserve the satisfaction of formulas with respect to the appropriate class of structures (see [9]). It has been also proved in [10] that
SCI
 can serve as a basis for expressing many-valued logics. Furthermore, it has been shown that the weakest non-Fregean logic
MGL
 (Minimal Grzegorczyk Logic) introduced in [11] is able to express most non-classical logics, including uncountably many extensions of
SCI
 and paraconsistent non-Fregean Grzegorczyk’s logics. Thus,
MGL
 can be treated as a generic non-Fregean logic.The non-Fregean approach could be relevant in cognitive science applications as well as in natural language processing. Last but not least, research on non-Fregean logics could lead to a better understanding of the capabilities and relationships of logics with mutually incompatible languages and semantics. Studies on various versions of non-Fregean logic may also shed light on which class of logics offers the most adequate account of logical symbols from point of view of natural language.In this paper, we focus on deduction systems for the logic
SCI
. The deduction system for
SCI
 was originally defined in a Hilbert-style. Since then, some other systems for
SCI
 have been proposed: Gentzen sequent calculus ([12,13,14]) and a dual tableau system ([15,16]). The aim of the paper is to present a new dual tableau system for
SCI
, which is suitable for automated reasoning in
SCI
. The main advantage of the new system is that, contrary to previously known systems, it is more efficient: it does not involve any substitution rule, its rules for the identity connective do not branch a proof tree, and it generates shorter and simpler proof trees.The paper consists of five sections: in Section 2, we present the basics of the non-Fregean propositional logic
SCI
, that is, its language, semantics, and axiomatization. In Section 3 and Section 4, we briefly survey sequent calculus and a dual tableau system for
SCI
, respectively. In Section 5, we present a new dual tableau system for
SCI
 and prove its soundness and completeness. Finally, in Section 6, we discuss and compare the systems presented in the paper. 2. The Non-Fregean Propositional Logic
SCI
The vocabulary of the language of the non-fregean propositional logic,
SCI
, consists of the symbols from the following pairwise disjoint sets:

V
=
{

p
1

,

p
2

,

p
3

,
…
}

—a countable infinite set of propositional variables;

{
¬
,
∨
,
∧
,
→
,
↔
,
≡
}

—the set of propositional operations of negation ¬, disjunction ∨, conjunction ∧, implication →, equivalence ↔, and identity ≡.The set
FOR
 of all
SCI
-formulas is the smallest set including
V
 and closed with respect to all propositional operations.An
SCI
-model is a structure

M
=
(
U
,
∼
,
⊔
,
⊓
,
⇒
,
⇔
,
∘
,
D
)

, where U is a non-empty set referred to as a universe, D is any non-empty proper subset of U, and

∼
,
⊔
,
⊓
,
⇒
,
⇔
,
∘

 are operations on U with arities 1, 2, 2, 2, 2, 2, respectively, such that, for all

a
,
b
∈
U

 the following hold:(SCI1)

∼
a
∈
D
 

iff

 
(
a
∉
D
)

;(SCI2)

a
⊔
b
∈
D
 

iff

 
(
a
∈
D
 

or

 
b
∈
D
)

;(SCI3)

a
⊓
b
∈
D
 

iff

 
(
a
∈
D
 

and

 
b
∈
D
)

;(SCI4)

a
⇒
b
∈
D
 

iff

 
(
a
∉
D
 

or

 
b
∈
D
)

;(SCI5)

a
⇔
b
∈
D
 

iff

 
(
a
∈
D
 

if
 
and
 
only
 
if
 

b
∈
D
)

;(SCI6)

a
∘
b
∈
D
 

iff

 
a
=
b

.Let
M
 be an
SCI
-model. A valuation in
M
 is any mapping

v
:
FOR
→
U

 such that

v
(
p
)
∈
D

, for every

p
∈
V

, and the following conditions hold for all
SCI
-formulas:


v
(
¬
φ
)
=
∼
v
(
φ
)



v
(
φ
→
ψ
)
=
v
(
φ
)
⇒
v
(
ψ
)



v
(
φ
∨
ψ
)
=
v
(
φ
)
⊔
v
(
ψ
)



v
(
φ
∧
ψ
)
=
v
(
φ
)
⊓
v
(
ψ
)



v
(
φ
↔
ψ
)
=
v
(
φ
)
⇔
v
(
ψ
)



v
(
φ
≡
ψ
)
=
v
(
φ
)
∘
v
(
ψ
)

Given an
SCI
-model
M
 and a valuation v in
M
, an
SCI
-formula
φ
 is said to be satisfied in
M
 by v (in short

M
,
v
⊨
φ

) whenever

v
(
φ
)
∈
D

. An
SCI
-formula
φ
 is true in
M
 if and only if for every v in
M
,

M
,
v
⊨
φ

. A formula is
SCI
-valid if and only if it is true in all
SCI
-models. An
SCI
-formula
φ
 is said to be satisfiable in an
SCI
-model
M
 whenever there exists a valuation v on
M
 such that

M
,
v
⊨
φ

. A model is referred to as finite if its universe is finite.The intended philosophical interpretation of an
SCI
-model

M
=
(
U
,
∼
,
⊔
,
⊓
,
⇒
,
⇔
,
∘
,
D
)

 is as follows: U is the set of situations (denotations of sentences); D is the set of facts, that is, it consists of those situations that correspond to true sentences; the operations correspond to the formation of new formulas with connectives.The logic
SCI
 is two-valued. We may define the logical value of a formula
φ
 in a model
M
 as:



v
a

l
M


(
φ
)


=
df







t
r
u
e

,






i
f
 
f
o
r
 
e
v
e
r
y
 
v
 
i
n
 
M
,
v
(
φ
)
∈
D

,







f
a
l
s
e

,






o
t
h
e
r
w
i
s
e
.











The following proposition shows that
SCI
 is extensional in the sense that any subformula
ψ
 of an
SCI
-formula
φ
 can be replaced with another formula
ϑ
 denoting the same as
ψ
 without affecting the denotation of
φ
.Proposition 1. Let
M
 be an
SCI
-model, let v be a valuation in
M
, let φ be an
SCI
-formula containing a subformula ψ, and let

φ
′

 be the result of replacing some occurrences of ψ in φ by a formula ϑ. Then,

M
,
v
⊨
ψ
≡
ϑ

 implies

M
,
v
⊨
φ
≡

φ
′


.The proof of Proposition 1 is presented in [16]. It should be emphasized that two-valuedness and extensionality concern different levels. Two-valuedness is a property of truth values, while extensionality holds for denotations.As shown in [3], the logic
SCI
 has the finite model property and is decidable:Theorem 1 (Finite model property and decidability of
SCI
). The logic
SCI
 has the finite model property, i.e., every satisfiable
SCI
-formula is satisfiable in a finite
SCI
-model. Furthermore, the logic
SCI
 is decidable.Corollary 1. Let T be a set of
SCI
-formulas such that T is true in all finite
SCI
-models. Then, T is true in all infinite
SCI
-models as well.The proof of the above corollary can be found in [8].A Hilbert-style axiomatization of
SCI
 consists of axiom schemas of classical propositional logic
PC
, which characterize the operations

¬
,
∨
,
∧
,
→
,
↔

, and the following axiom schemas for the identity operation ≡:(

≡
1

)

φ
≡
φ

;(

≡
2

)

(
φ
≡
ψ
)
→
(
¬
φ
≡
¬
ψ
)

;(

≡
3

)

(
φ
≡
ψ
)
→
(
φ
→
ψ
)

;(

≡
4

)

[
(
φ
≡
ψ
)
∧
(
ϑ
≡
ξ
)
]
→
[
(
φ
#
ϑ
)
≡
(
ψ
#
ξ
)
]

, for

#
∈
{
∧
,
∨
,
→
,
↔
,
≡
}

.The only rule of inference is modus ponens. The notion of provability of a formula is defined as usual. Thus, an
SCI
-formula
φ
 is said to be
SCI
-provable whenever there exists a finite sequence


φ
1

,
…
,

φ
n


 of
SCI
-formulas,

n
≥
1

, such that


φ
n

=
φ

 and each

φ
i

,

i
∈
{
1
,
…
,
n
}

, is an
SCI
-axiom or follows from earlier formulas in the sequence by the modus ponens rule. It is easy to see that all theorems of classical propositional logic are
SCI
-provable formulas.Fact 2. For every
PC
-formula φ, the following conditions are equivalent:1.φ is provable in the classical propositional logic.2.φ is
SCI
-provable.Soundness and completeness of
SCI
 with respect to the class of
SCI
-models was proved in [3].Theorem 2 (Soundness and Completeness of
SCI
). For every
SCI
-formula φ, the following conditions are equivalent:1.φ is
SCI
-provable.2.φ is
SCI
-valid.The logic
SCI
 is very weak as it does not impose any specific assumptions on the cardinality of the universe of situations (except that it has at least two elements). Furthermore, it does not assume any specific assumptions on the identities of equivalent formulas—for instance, the formula

(
φ
∧
ψ
)
≡
(
ψ
∧
φ
)

 is not
SCI
-valid. Indeed, the reduct

(
U
,
∼
,
⊔
,
⊓
)

 of an
SCI
-model is not necessarily a Boolean algebra, since, for example,

a
⊓
b
=
b
⊓
a

 is not true in all
SCI
-models. Consider an
SCI
-model

M
=
(
U
,
∼
,
⊔
,
⊓
,
⇒
,
⇔
,
∘
,
D
)

, where

U
=
{
0
,
1
,
2
}

,

D
=
{
1
,
2
}

, and the operations

∼
,
⊔
,
⊓
,
⇒
,
⇔
,
∘

 are defined by:


∼
a

=
df






0
,






i
f
 
a
≠
0

,






1
,






o
t
h
e
r
w
i
s
e

,








a
⊔
b

=
df






0
,






i
f
 
a
=
0
 
a
n
d
 
b
=
0

,






1
,






o
t
h
e
r
w
i
s
e

,








a
⇒
b

=
df






0
,






i
f
 
a
≠
0
 
a
n
d
 
b
=
0

,






1
,






o
t
h
e
r
w
i
s
e

,








a
⊓
b

=
df






0
,






i
f
 
a
=
0
,
 
o
r
 
b
=
0

,






1
,






i
f
 
b
=
2
 
a
n
d
 
a
≠
0

,






2
,






o
t
h
e
r
w
i
s
e

,








a
⇔
b

=
df






0
,






i
f
 
a
≠
0
,
b
=
0
 
o
r
 
a
=
0
,
b
≠
0

,






1
,






o
t
h
e
r
w
i
s
e

,








a
∘
b

=
df






0
,






i
f
 
a
≠
b

,






a
,






i
f
 
a
=
b
 
a
n
d
 
a
≠
0

,






1
,






o
t
h
e
r
w
i
s
e

.






It is easy to verify that such a structure is an
SCI
-model. Then, the following hold in the model
M
:

2
⊓
1
=
2

 and

1
⊓
2
=
1

. Hence,

a
⊓
b
=
b
⊓
a

 is not true in this model.Therefore, if we remove from the
SCI
-language some of the classical propositional connectives and define them equationally as usual, then the logic obtained in this way would not be a notational variant of
SCI
. Indeed, suppose that we remove the connective ∨ from
SCI
-language, and we add the definition

φ
∨
ψ

=
df

¬
φ
→
ψ

. In such a logic, the formula

(
φ
∨
ψ
)
≡
(
¬
φ
→
ψ
)

 would be valid, while it is not an
SCI
-valid formula.However, in some applications, there may be a need to impose some specific properties of situations or interactions between them. If we add additional assumptions on the universe of situations, we will obtain an extension of
SCI
. For example, if we add to the set of
SCI
-axioms the so-called Fregean axiom



(
Fregean

Axiom
)

(
φ
↔
ψ
)
→
(
φ
≡
ψ
)
,






which identifies the denotations of sentences with their truth values, then we get classical propositional logic. It is easy to see that classical propositional logic is the strongest among all propositional extensions of
SCI
. As shown in [4], there are uncountably many different non-Fregean theories stronger than
SCI
 and weaker than classical propositional logic.In the rest of the paper, we present and discuss two types of deduction systems for
SCI
: a sequent-style and a tableau-like systems. Although, as mentioned above, any restriction of the
SCI
-language leads to a different logic than the original
SCI
, to make the presentation more readable, we will assume that
SCI
-language consists of three connectives: ¬, →, and ≡. In the context of deduction systems, this restriction is minor because each of the presented system can be easily extended to the full
SCI
-language without loss of soundness and completeness. 3. Sequent-Style Formalizations for
SCI
Sequent calculi constitute an important type of deduction systems. They were designed by Gerhard Gentzen for purely theoretical reasons, mainly as a theoretical framework for investigations properties of logical consequence. However, it turned out that Gentzen sequent calculus is not only another way of axiomatization of classical logic, but also a good alternative to Hilbert (axiomatic) systems: it is much easier and more convenient to use in practice. Anyone who has tried to construct an axiomatic proof of even a very simple formula knows that such a proof construction requires a lot of effort and creativity. The reason lies in the very nature of Hilbert systems: to prove a formula we must construct a sequence of formulas with this formula as the last element of the sequence. Thus, the main challenge in building axiomatic proofs is: How can we find the way to the formula in question? The Hilbert system itself does not provide any strategy on how to find proofs; it only says which sequences of formulas are proofs. In Gentzen systems, this weakness is mitigated by changing the notion of a proof: in order to build a proof of a formula, we start with that formula and decompose it according to the rules of the system; if the last formulas satisfy certain conditions, then we can conclude that a formula is a theorem. Thus, in each step of decomposition, a reasoner knows the given formulas and can analyze their possible derivations. This means that sequent calculus is a goal-oriented tool, and so it could be more easily implemented than Hilbert-style systems. In recent decades, systems that could be easily automated have become increasingly important, mainly due to growing interests in applications of logic and the rapid development of information technologies. Gentzen sequent calculus provides—among other systems like tableaux or resolution—a good tool for automated theorem proving.The first sequent calculus for the logic
SCI
 was built by Michaels (see [12]); then, it has been simplified by Wasilewska in [13]) and modified by Chlebowski in [14]. Below, we present the basics of a sequent calculus for
SCI
, which is a version of systems from [12] and [13] adjusted to the well known sequent axiomatization of classical propositional logic.By
Γ
,
Δ
,
Σ
, with indices if necessary, we will denote finite (possibly empty) sequences of
SCI
-formulas. If
Γ
 and
Δ
 are sequences


φ
1

,
…
,

φ
n


 and


ψ
1

,
…
,

ψ
m


, respectively, then

Γ
,
Δ

 denotes a sequence


φ
1

,
…
,

φ
n

,

ψ
1

,
…
,

ψ
m


. Similarly, if
φ
 is a formula and

Γ
=
(

φ
1

,
…
,

φ
n

)

 is a sequence of formulas, then

φ
,
Γ

 (resp.

Γ
,
φ

) denotes the sequence

φ
,

φ
1

,
…
,

φ
n


 (resp.


φ
1

,
…
,

φ
n

,
φ

). A sequence that contains only propositional variables (resp. identities of the form

φ
≡
ψ

) will be referred to as an atomic sequence (resp. an identities sequence). If

φ
,
ψ
,
ϑ

 are
SCI
-formulas, then, by

φ
[
ψ
/
ϑ
]

, we denote any sequence consisting of all formulas, including
φ
, obtained from
φ
 by replacing at least one occurrence of
ψ
 by
ϑ
. Clearly, given formulas

φ
,
ψ
,
ϑ

, a sequence

φ
[
ψ
/
ϑ
]

 is finite. If
Γ
 is a finite sequence of
SCI
-formulas and

ψ
,
ϑ

 are
SCI
-formulas, then

Γ

[
ψ
/
ϑ
]


=
df


{
φ

[
ψ
/
ϑ
]

:
φ
∈
Γ
}


.A sequent is an expression of the form

Γ
⊢
Δ

, where
Γ
 (
Δ
) is referred to as antecedent (resp. succedent) of a sequent. Validity of a sequent

Γ
⊢
Δ

, for

Γ
=
(

φ
1

,
…
,

φ
n

)

 and

Δ
=
(

ψ
1

,
…
,

ψ
m

)

 is equivalent with validity of a formula


(

φ
1

∧
…
∧

φ
n

)

→

(

ψ
1

∨
…
∨

ψ
m

)


. Thus, if a sequence of formulas is on the left of the ⊢, then it is considered conjunctively, while, if it is on the right of the ⊢, the sequence of formulas is considered disjunctively. Sequent rules can be divided on the left and right rules, which in general correspond to valid formulas of the form


(

φ
1

∧
…
∧

φ
n

)

→

(

ψ
1

∨
…
∨

ψ
m

)


. Sequent rules have the following general forms:





(
left

rule
)





ψ
1

,

φ
1

,
…
,

φ
n

,
Γ
⊢
Δ


|

…

|



ψ
m

,

φ
1

,
…
,

φ
n

,
Γ
⊢
Δ



φ
1

,
…
,

φ
n

,
Γ
⊢
Δ


,













(
right

rule
)




Γ
⊢
Δ
,

ψ
1

,
…
,

ψ
m

,

φ
1



|

…

|


Γ
⊢
Δ
,

ψ
1

,
…
,

ψ
m

,

φ
n



Γ
⊢
Δ
,

ψ
1

,
…
,

ψ
m



.







There are two major groups of sequent rules: logical and structural. A logical rule introduces a new formula either on the left or on the right of the ⊢. A structural rule operates on the structure of the sequents, ignoring the exact shape of the formulas. Some sequents are distinguished as axioms. In order to prove a sequent

Γ
⊢
Δ

, we write the sequent and then proceed to construct a tree in an upward direction. In each step, we follow the rules of a sequent calculus until we reach a closing sequent that is a sequent that is an axiom. If we apply a rule in which the symbol ‘|’ occurs, then the tree splits. Each split in a tree adds a new branch. If a given branch has at its top an axiom, then it is called closed; otherwise, it is open. If all branches are closed, then a derivation of a sequent is its proof.The sequent calculus for
SCI
, denoted by

G
SCI

, consists of logical rules for the classical connectives from Table 1, the rule for the identity connective depicted in Table 2, and structural rules given in Table 3.

G
SCI

-axioms are sequents of either of the following forms, for any
SCI
-formula
φ
 and any finite sequences
Γ
,

Γ
′

,
Δ
,

Δ
′

 of
SCI
-formulas:

Γ
,
φ
,

Γ
′

⊢
Δ
,
φ
,

Δ
′


 or

Γ
,
⊢
Δ
,
φ
≡
φ
,

Δ
′


.An
SCI
-formula
φ
 is said to be

G
SCI

-provable if and only if there is a

G
SCI

-proof for the sequent

⊢
φ

. As proved in [12] (cf. [13]), the system

G
SCI

 is sound and complete:Theorem 3 (Soundness and Completeness of

G
SCI

). Let φ be an
SCI
-formula. Then, the following conditions are equivalent:1.φ is
SCI
-valid;2.φ is

G
SCI

-provable.Note that the rule

(

≡

G
SCI


)

 for the identity connective is a branching rule, and it can be applied only if no other logical rule can be applied that is all formulas in sequents are either propositional variables or identities. Furthermore, observe that the rule

(

≡

G
SCI


)

 corresponds to the extensionality property as stated in Proposition 1. This means that the rule

(

≡

G
SCI


)

 reflects the following property of the logic
SCI
: if

(
(
φ
≡
ψ
)
∧
ϑ
)
→
χ

 is
SCI
-valid, then


(

(
φ
≡
ψ
)

∧

ϑ
′

)

→

χ
′


 is
SCI
-valid, where

φ
,
ψ
,
ϑ
,
χ

 are any
SCI
-formulas and

ϑ
′

 (resp.

χ
′

) is the result of replacing some occurrences of
φ
 in
ϑ
 (resp.
χ
) by a formula
ψ
.Clearly, the rule

(

≡

G
SCI


)

 uses substitution, thus it may produce many formulas which are not necessary to close a tree. Chlebowski in 2018 proposed two sound and complete sequent calculi for
SCI
 whose rules for identity do not make use of substitution. The idea of Chlebowski’s systems is to translate each of the
SCI
-axiom schemas

(

≡
3

)

–

(

≡
4

)

 to sequent rules. For instance, a left rule corresponding to the axiom schema

(

≡
4

)

 for → has the following form:






(
φ
→
ϑ
)
≡
(
ψ
→
χ
)
,
φ
≡
ψ
,
ϑ
≡
χ
,
Γ
⊢
Δ


φ
≡
ψ
,
ϑ
≡
χ
,
Γ
⊢
Δ


.






For details of Chlebowski’s systems, we refer the reader to [14].Figure 1 presents a closed

G
SCI

-derivation of the formula


(

p
1

≡

p
2

)

→

(

p
1

→

p
2

)


, which is an instance of the axiom schema

(

≡
3

)

, while, in Figure 2, we show how to prove in

G
SCI

 the formula


(

p
1

≡

p
2

)

→

[

(

p
2

≡

p
3

)

→

(

p
1

≡

p
3

)

]


, which expresses the fact that the identity connective represents a transitive relation. 4. Dual Tableau System

DT
SCI

Dual tableau systems are based on Rasiowa–Sikorski diagrams for classical predicate logic (see [17]). They are top–down systems determined by the rules of inferences and axioms. Rules have the following form

(
rule
)



Φ


Φ
1



|

…

|



Φ
n



,

n
≥
1

, where
Φ
,

Φ
1

, …,

Φ
n

 are finite sets of formulas. The set
Φ
 is called the premise of the rule. Sets

Φ
1

, …,

Φ
n

 are said to be conclusions. Some systems allow infinitary rules with infinitely countable many conclusions. The rules are supposed to preserve the validity of the sets of formulas to which they are applied, where the validity of a finite set of formulas is understood as the validity of the disjunction of its elements. Thus, a comma in the sets of a rule

(
rule
)

 can be interpreted as the meta-disjunction, while branching ‘|’ as the meta-conjunction. The rules apply to finite sets of formulas. A rule

(
rule
)

 is applicable to a finite set X, whenever

X
=
Φ

, and there is

i
∈
{
1
,
…
,
n
}

 such that

X
≠

Φ
i


. Axioms are distinguished valid sets of formulas, also referred to as axiomatic sets. The key notion in the methodology of dual tableau systems is a proof tree. A proof tree for a formula
φ
 is a (finitely) branching tree whose root consists of the set

{
φ
}

 and each node of the tree, except the root, is obtained by an application of a rule to its predecessor node. A formula
φ
 is said to be provable, whenever there is a proof tree for
φ
 such that all of its branches ends with an axiom.Dual tableau systems are validity checkers that are in order to prove a formula
φ
 we build a proof tree directly for that formula. It distinguishes dual tableaux from tableau systems, which are unsatisfiability checkers, as in tableau systems in order to prove a formula a proof tree for its negation is constructed.Over the years, dual tableaux have been constructed for a great variety of logics, in particular for modal, intuitionistic, relevant, many-valued, temporal, spatial, fuzzy, dynamic programming logics, among others. A very recent comprehensive survey on the foundations and applications of dual tableaux is the book [16].The first sound and complete dual tableau for the fragment of
SCI
-language was presented in [15]. A dual tableau for the full
SCI
-language is described in [16]. The system presented in [15] (resp. [16]) was defined for
SCI
-language which among its classical connectives contains ¬, ∧, and ∨ (resp. ¬, ∧, ∨, →, ↔). In this section, we present the basics of a dual tableau from [16] adjusted to
SCI
-language that contains only three connectives ¬, →, and ≡. For the simplicity of our presentation, we will write

φ
≢
ψ

 instead of

¬
(
φ
≡
ψ
)

.The dual tableau system for
SCI
, denoted by

DT
SCI

, consists of

DT
SCI

-axiomatic sets, decomposition rules

(
¬
)

,

(
→
)

,

(
¬

→
)

 presented in Table 4, and the specific rule

(
≡
)

 depicted in Table 5. Decomposition rules enable us to decompose formulas built by means of the classical connectives ¬ and →, while the specific rule reflects properties of the identity connective ≡.

DT
SCI

-axiomatic sets have either of the following forms, where
φ
 is an
SCI
-formula and X is a finite (possible empty) set of
SCI
-formulas:

{
φ
≡
φ
}
∪
X

 or

{
φ
,
¬
φ
}
∪
X

.A finite set of
SCI
-formulas

{

φ
1

,
…
,

φ
n

}

 is said to be
SCI
-valid whenever the disjunction of its elements is
SCI
-valid that is for every
SCI
-model
M
 and for every valuation v in
M
 there exists

i
∈
{
1
,
…
,
n
}

 such that

M
,
v
⊨

φ
i


. A

DT
SCI

-proof tree for an
SCI
-formula
φ
 is a finitely branching tree whose nodes are sets of formulas satisfying the following conditions:the formula
φ
 is at the root of this tree,each node except the root is obtained by an application of a

DT
SCI

-rule to its predecessor node,a node does not have successors whenever it is a

DT
SCI

-axiomatic set or none of the rules applies to its set of formulas.A branch of a

DT
SCI

-proof tree is said to be closed whenever it contains a node with a

DT
SCI

-axiomatic set of formulas. A

DT
SCI

-proof tree is closed whenever all of its branches are closed. A formula
φ
 is

DT
SCI

-provable whenever there is a closed

DT
SCI

-proof tree for
φ
, which is then referred to as its

DT
SCI

-proof.Figure 3 presents a

DT
SCI

-proof for the formula


(

p
1

≡

p
2

)

→

(

p
1

→

p
2

)


, which is an instance of the axiom schema

(

≡
3

)

. Figure 4 presents a closed

DT
SCI

-proof tree for the formula


(

p
1

≡

p
2

)

→

[

(

p
2

≡

p
3

)

→

(

p
1

≡

p
3

)

]


. In each node of the proof tree, we underline the formula to which a rule has been applied during the construction of the proof tree, and we indicate only those formulas in a node which are essential for this construction.The proof of soundness and completeness of

DT
SCI

-system is presented in [16] (cf. [15]):Theorem 4 (Soundness and Completeness of

DT
SCI

). Let φ be an
SCI
-formula. Then, the following conditions are equivalent:1.φ is
SCI
-valid;2.φ is

DT
SCI

-provable.As in

G
SCI

-system, the rule for the identity connective of the system

DT
SCI

 branches a tree and involves use of substitution. In the next section, we present a new dual tableau that has no such disadvantages. 5. A Substitution-Free Dual Tableau for
SCI
In this section, we present the system

DT
SCI
*

, which is a modification of

DT
SCI

-system by replacing the rule

(
≡
)

 with several rules for the identity connective that do not involve substitutions. The system

DT
SCI
*

 consists of

DT
SCI

-decomposition rules presented in Table 4 (see Section 4) and the specific rules presented in Table 6. The specific rule

(
ref
)

 (resp.

(
sym
)

,

(
tran
)

) expresses reflexivity (resp. symmetry, transitivity) of a relation which in
SCI
-models corresponds to the identity connective. Thus, specific rules

(
ref
)

,

(
sym
)

, and

(
tran
)

 reflect the fact that the relation corresponding to the identity connective is an equivalence relation. The specific rule

(

≡
¬

)

 (resp.

(

≡
→

)

,

(

≡
≡

)

) expresses the instance of
SCI
-axiom

(

≡
2

)

 (resp.

(

≡
4

)

 for → and

(

≡
4

)

 for ≡) presented in Section 2. Therefore, specific rules

(

≡
¬

)

,

(

≡
→

)

, and

(

≡
≡

)

 correspond to the extensionality property for connectives ¬, →, and ≡ (see Proposition 1). As the identity connective can be characterized as an operation that satisfies the extensionality property and represents an equivalence relation, we will show that specific rules

(
ref
)

,

(
sym
)

,

(
tran
)

,

(

≡
¬

)

,

(

≡
→

)

, and

(

≡
≡

)

 are sufficient to prove completeness of the system

DT
SCI
*

.The axiomatic sets of

DT
SCI
*

 have either of the following forms, where

φ
,
ψ

 are any
SCI
-formulas and X is a finite (possible empty) set of
SCI
-formulas:


(

Ax

DT
SCI
*

1

)



{
φ
≡
φ
}
∪
X

,

(

Ax

DT
SCI
*

2

)



{
φ
,
¬
φ
}
∪
X

,

(

Ax

DT
SCI
*

3

)



{
φ
,
¬
ψ
,
φ
≢
ψ
}
∪
X

,

(

Ax

DT
SCI
*

4

)



{
¬
φ
,
ψ
,
φ
≢
ψ
}
∪
X

.The notions of an
SCI
-valid set of formulas, a

DT
SCI
*

-proof tree, a closed branch of such a tree, a closed

DT
SCI
*

-proof tree, and

DT
SCI
*

-provability are defined in a similar way as for

DT
SCI

-system in Section 4. Observe that none of the specific rules split a tree or use substitutions.Now, we will prove the soundness and completeness of

DT
SCI
*

-system.Proposition 3 (Correctness of

DT
SCI
*

-rules).For every

DT
SCI
*

-rule

(
rule
)

, the premise of
rule
 is
SCI
-valid if and only if all of its conclusions are
SCI
-valid.Proof.  The proof for decomposition rules is straightforward, so we will prove the proposition for the specific rules of

DT
SCI
*

:

(
ref
)

,

(
sym
)

,

(
tran
)

,

(

≡
¬

)

,

(

≡
→

)

,

(

≡
≡

)

. Let

φ
,
ψ
,
ϑ
,
χ

 be any
SCI
-formulas and let X be a finite (possibly empty) set of
SCI
-formulas. Observe that, in each of the specific

DT
SCI
*

-rules, the premise of a rule is a subset of its conclusion. Thus, if the premise is
SCI
-valid, then so is its conclusion. Therefore, it suffices to show that
SCI
-validity of the conclusion of a rule implies
SCI
-validity of its premise.Correctness of the rule

(
ref
)

Assume

{
φ
≢
φ
}
∪
X

 is
SCI
-valid and suppose X is not
SCI
-valid. Then, there are an
SCI
-model
M
 and a valuation v in
M
 such that, for every

ξ
∈
X

,

M
,
v
⊭
ξ

. Thus, since

{
φ
≢
φ
}
∪
X

 is
SCI
-valid and

M
,
v
⊭
ξ

 for every

ξ
∈
X

, we obtain

M
,
v
⊨
φ
≢
φ

, so

M
,
v
⊭
φ
≡
φ

. However, all
SCI
-formulas,
SCI
-models
M
, and valuations satisfy

M
,
v
⊨
φ
≡
φ

, a contradiction.Correctness of the rule

(
sym
)

Assume that

{
ψ
≢
φ
,
φ
≢
ψ
}
∪
X

 is
SCI
-valid and suppose

{
φ
≢
ψ
}
∪
X

 is not
SCI
-valid. Then, there exist an
SCI
-model
M
 and a valuation v in
M
 such that

M
,
v
⊭
φ
≢
ψ

 and, for every

ξ
∈
X

,

M
,
v
⊭
ξ

. Thus,

M
,
v
⊨
φ
≡
ψ

, which means that

v
(
φ
)
=
v
(
ψ
)

. Furthermore, by the assumption, the model
M
 and the valuation v must satisfy the formula

ψ
≢
φ

, so

v
(
ψ
)
≠
v
(
φ
)

, a contradiction.Correctness of the rule

(
tran
)

Assume

{
φ
≢
ϑ
,
φ
≢
ψ
,
ψ
≢
ϑ
}
∪
X

 is
SCI
-valid and suppose

{
φ
≢
ψ
,
ψ
≢
ϑ
}
∪
X

 is not
SCI
-valid. Then, there exists an
SCI
-model
M
 and a valuation v in
M
 that do not satisfy any formula from the set

{
φ
≢
ψ
,
ψ
≢
ϑ
}
∪
X

, so

M
,
v
⊨
φ
≡
ψ

 and

M
,
v
⊨
ψ
≡
ϑ

. Hence, we obtain

v
(
φ
)
=
v
(
ψ
)
=
v
(
ϑ
)

. However, by the assumption, it must hold that

M
,
v
⊨
φ
≢
ϑ

, which imply

v
(
φ
)
≠
v
(
ϑ
)

, a contradiction.Correctness of the rule

(

≡
¬

)

Assume

{
¬
φ
≢
¬
ψ
,
φ
≢
ψ
}
∪
X

 is
SCI
-valid and suppose

{
φ
≢
ψ
}
∪
X

 is not
SCI
-valid. Then, there exist an
SCI
-model

M
=
(
U
,
∼
,
⇒
,
∘
,
D
)

 and a valuation v such that

M
,
v
⊨
φ
≡
ψ

 that is

v
(
φ
)
=
v
(
ψ
)

. On the other hand, by the assumption,

M
,
v
⊨
¬
φ
≢
¬
ψ

, which imply

v
(
¬
φ
)
≠
v
(
¬
ψ
)

. However, if

v
(
φ
)
=
v
(
ψ
)

, then clearly

v
(
¬
φ
)
=
∼
v
(
φ
)
=
∼
v
(
ψ
)
=
v
(
¬
ψ
)

, which contradicts

v
(
¬
φ
)
≠
v
(
¬
ψ
)

.Correctness of the rule

(

≡
→

)

Assume

{
(
φ
→
ϑ
)
≢
(
ψ
→
χ
)
,
φ
≢
ψ
,
ϑ
≢
χ
}
∪
X

 is
SCI
-valid and suppose

{
φ
≢
ψ
,
ϑ
≢
χ
}
∪
X

 is not
SCI
-valid. Then, there exist an
SCI
-model

M
=
(
U
,
∼
,
⇒
,
∘
,
D
)

 and a valuation v such that

M
,
v
⊨
φ
≡
ψ

 and

M
,
v
⊨
ϑ
≡
χ

, that is,

v
(
φ
)
=
v
(
ψ
)

 and

v
(
ϑ
)
=
v
(
χ
)

. Hence, due to the definition of an
SCI
-model, we obtain:

v
(
φ
→
ϑ
)
=
v
(
φ
)
⇒
v
(
ϑ
)
=
v
(
ψ
)
⇒
v
(
χ
)
=
v
(
ψ
→
χ
)

. Therefore,

M
,
v
⊨
(
φ
→
ϑ
)
≡
(
ψ
→
χ
)

. However, by the assumption,

M
,
v
⊨
(
φ
→
ϑ
)
≢
(
ψ
→
χ
)

, a contradiction.Correctness of the rule

(

≡
≡

)

Assume

{
(
φ
≡
ϑ
)
≢
(
ψ
≡
χ
)
,
φ
≢
ψ
,
ϑ
≢
χ
}
∪
X

 is
SCI
-valid and suppose

{
φ
≢
ψ
,
ϑ
≢
χ
}
∪
X

 is not
SCI
-valid. Then, there exist an
SCI
-model

M
=
(
U
,
∼
,
⇒
,
∘
,
D
)

 and a valuation v such that

M
,
v
⊨
φ
≡
ψ

 and

M
,
v
⊨
ϑ
≡
χ

 that is

v
(
φ
)
=
v
(
ψ
)

 and

v
(
ϑ
)
=
v
(
χ
)

. Thus, by the definition of an
SCI
-model, we obtain that

v
(
φ
≡
ϑ
)
=
v
(
φ
)
∘
v
(
ϑ
)
=
v
(
ψ
)
∘
v
(
χ
)
=
v
(
ψ
≡
χ
)

, and so

M
,
v
⊨
(
φ
≡
ϑ
)
≡
(
ψ
≡
χ
)

. By the assumption,

M
,
v
⊨
(
φ
≡
ϑ
)
≢
(
ψ
≡
χ
)

, a contradiction. □Proposition 4 (Validity of

DT
SCI
*

-axiomatic sets). All the

DT
SCI
*

-axiomatic sets are
SCI
-valid.Proof.  Let
φ
,
ψ
 be any
SCI
-formulas and let X be any finite (possibly empty) set of
SCI
-formulas. The proof of validity of sets

(

Ax

DT
SCI
*

1

)

 and

(

Ax

DT
SCI
*

2

)

 is obvious. By way of example, we will prove validity of sets

(

Ax

DT
SCI
*

3

)

, since the proof for

(

Ax

DT
SCI
*

4

)

 is similar. Suppose a set

{
φ
,
¬
ψ
,
φ
≢
ψ
}
∪
X

 is not
SCI
-valid. Then, there exist an
SCI
-model

M
=
(
U
,
∼
,
⇒
,
∘
,
D
)

 and a valuation v such that

M
,
v
⊭
φ

,

M
,
v
⊭
¬
ψ

, and

M
,
v
⊭
φ
≡
ψ

. Thus, by the definition of an
SCI
-model,

v
(
φ
)
∉
D

,

∼
v
(
ψ
)
∉
D

, and

∼
(
v
(
φ
)
∘
v
(
ψ
)
)
∉
D

. However, this means that

v
(
φ
)
∉
D

,

v
(
ψ
)
∈
D

, and

v
(
φ
)
=
v
(
ψ
)

, which is not possible since the latter implies

v
(
φ
)
∈
D

 iff

v
(
ψ
)
∈
D

. □Due to Propositions 3 and 4, the soundness of

DT
SCI
*

 can be easily proved:Theorem 5 (Soundness of

DT
SCI
*

). If an
SCI
-formula is

DT
SCI
*

-provable, then it is
SCI
-valid.Proof.  Let
φ
 be a

DT
SCI
*

-provable formula. Then, there exists a closed

DT
SCI
*

-proof tree for
φ
 that is all of its branches end with

DT
SCI
*

-axiomatic sets. By Proposition 4, all

DT
SCI
*

-axiomatic sets are
SCI
-valid, so the leaves in the closed

DT
SCI
*

-proof tree for
φ
 are
SCI
-valid sets of formulas. Moreover, by Proposition 3, if conclusions of a rule are
SCI
-valid, then so is its premise. Therefore, going from the leaves to the root of the tree, in each step, we obtain nodes that are
SCI
-valid. Hence, the root

{
φ
}

 is
SCI
-valid, and so we conclude that the formula
φ
 is
SCI
-valid. □In order to prove completeness of

DT
SCI
*

, we will construct an
SCI
-model and a valuation that do not satisfy a formula, which is not

DT
SCI
*

-provable. We call a branch b of a

DT
SCI
*

-proof tree

DT
SCI
*

-complete whenever it satisfies the following completion conditions for all
SCI
-formulas

φ
,
ψ
,
ϑ
,
χ

:Cpl(¬) If

¬
¬
φ
∈
b

, then

φ
∈
b

.Cpl(→) If

φ
→
ψ
∈
b

, then both

¬
φ
∈
b

 and

ψ
∈
b

.Cpl(

¬

→

) If

¬
(
φ
→
ψ
)
∈
b

, then either

φ
∈
b

 or

¬
ψ
∈
b

.Cpl(
ref
) For every
SCI
-formula
φ
,

φ
≢
φ
∈
b

.Cpl(
sym
) If

φ
≢
ψ
∈
b

, then

ψ
≢
φ
∈
b

.Cpl(
tran
) If

φ
≢
ψ
∈
b

 and

ψ
≢
ϑ
∈
b

, then

φ
≢
ϑ
∈
b

.Cpl(

≡
¬

) If

φ
≢
ψ
∈
b

, then

¬
φ
≢
¬
ψ
∈
b

.Cpl(

≡
→

) If

φ
≢
ψ
∈
b

 and

ϑ
≢
χ
∈
b

, then

(
φ
→
ϑ
)
≢
(
ψ
→
χ
)
∈
b

.Cpl(

≡
≡

) If

φ
≢
ψ
∈
b

 and

ϑ
≢
χ
∈
b

, then

(
φ
≡
ϑ
)
≢
(
ψ
≡
χ
)
∈
b

.A

DT
SCI
*

-proof tree is said to be

DT
SCI
*

-complete whenever each of its branches is either closed or

DT
SCI
*

-complete. The rules of

DT
SCI
*

-system guarantee that, for every
SCI
-formula, there is a complete

DT
SCI
*

-proof tree. A non-closed branch that is

DT
SCI
*

-complete will be referred to as open. The following property can be easily proved:Proposition 5 (Closed Branch Property). For every complete branch b of a

DT
SCI
*

-proof tree and for every
SCI
-formula φ, if both

φ
∈
b

 and

¬
φ
∈
b

, then the branch b is closed.Proof.  Let b be a complete branch of

DT
SCI
*

-proof tree and let
φ
 be an
SCI
-formula such that both

φ
∈
b

 and

¬
φ
∈
b

. Suppose b is not closed. We will prove the proposition by the induction on complexity of formulas. First, observe that all the

DT
SCI
*

-rules preserves propositional variables, negations of propositional variables, identities and negations of identities, that is, if a node contains
φ
 or

¬
φ

, for

φ
∈
V
∪
{
ψ
≡
ϑ
;
ψ
,
ϑ
∈
FOR
}

, then all of its successors contain these formulas. Thus, if

φ
∈
b

 and

¬
φ
∈
b

, then there exists a node t in branch b such that both

φ
∈
t

 and

¬
φ
∈
t

, which means that a node t is

DT
SCI
*

-axiomatic, and branch b is closed. Hence, the proposition holds for formulas from the set

V
∪
{
ψ
≡
ϑ
;
ψ
,
ϑ
∈
FOR
}

. Assume the proposition holds for
φ
 and
ψ
. We will show that it holds for formulas

¬
φ

 and

φ
→
ψ

. Assume

¬
φ
∈
b

 and

¬
¬
φ
∈
b

. Then, as b is a non-closed complete branch and

¬
¬
φ
∈
b

, by the completion condition Cpl(¬),

φ
∈
b

. Thus, we have

¬
φ
∈
b

 and

φ
∈
b

, so by the inductive hypothesis, b is closed. Now, let

φ
→
ψ
∈
b

 and

¬
(
φ
→
ψ
)
∈
b

. Since b is a non-closed complete branch and

φ
→
ψ
∈
b

, by the completion condition Cpl(→), we obtain that both

¬
φ
∈
b

 and

ψ
∈
b

. Similarly, by the completion condition Cpl(

¬

→

), we have that either

φ
∈
b

 or

¬
ψ
∈
b

. Therefore, either both

φ
∈
b

 and

¬
φ
∈
b

 or both

ψ
∈
b

 and

¬
ψ
∈
b

. Hence, by the inductive hypothesis, the branch b must be closed, which ends the proof. □Let b be an open branch of a

DT
SCI
*

-proof tree and let

R
∘

 be defined on the set of all
SCI
-formulas as follows:




(
φ
,
ψ
)

∈

R
∘


⟺
df


(
φ
≢
ψ
)

∈
b
.





Proposition 6. For every open branch b of a

DT
SCI
*

-proof tree,

R
∘

 is an equivalence relation on the set of all
SCI
-formulas.Proof.  Let b be an open branch of a

DT
SCI
*

-proof tree and let
φ
 be an
SCI
-formula. Then, by the completion condition Cpl(
ref
),

φ
≢
φ

 belongs to the branch b, and so


(
φ
,
φ
)

∈

R
∘


, that is,

R
∘

 is reflexive. Assume
φ
 and
ψ
 are
SCI
-formulas such that


(
φ
,
ψ
)

∈

R
∘


. Then,

φ
≢
ψ
∈
b

, and by the completion condition Cpl(
sym
),

ψ
≢
φ
∈
b

. Thus,


(
ψ
,
φ
)

∈

R
∘


, which means that

R
∘

 is symmetric. Now, assume that


(
φ
,
ψ
)

∈

R
∘


 and


(
ψ
,
ϑ
)

∈

R
∘


, that is, both formulas

φ
≢
ψ

 and

ψ
≢
ϑ

 are in b. Therefore, by the completion condition Cpl(
tran
),

φ
≢
ϑ
∈
b

, so


(
φ
,
ϑ
)

∈

R
∘


. Thus, the relation

R
∘

 is transitive. Hence, we have proved that

R
∘

 is an equivalence relation. □Proposition 7. For every open branch b of a

DT
SCI
*

-proof tree, the relation

R
∘

 is compatible with all the connectives of
SCI
.Proof.  Let b be an open branch of a

DT
SCI
*

-proof tree and let

φ
,
ψ
,
ϑ
,
χ

 be
SCI
-formulas. Assume


(
φ
,
ψ
)

∈

R
∘


, that is,

φ
≢
ψ
∈
b

. Then, due to the completion condition Cpl(

≡
¬

),

¬
φ
≢
¬
ψ
∈
b

, so


(
¬
φ
,
¬
ψ
)

∈

R
∘


. Thus,

R
∘

 is compatible with ¬. Now, let


(
φ
,
ψ
)

∈

R
∘


 and


(
ϑ
,
χ
)

∈

R
∘


, that is,

φ
≢
ψ
∈
b

 and

ϑ
≢
χ
∈
b

. Then, by the completion condition Cpl(

≡
→

), we obtain

(
φ
→
ϑ
)
≢
(
ψ
→
χ
)
∈
b

, that is,


(

(
φ
→
ϑ
)

,

(
ψ
→
χ
)

)

∈

R
∘


, so

R
∘

 is compatible with →. Finally, assume that


(
φ
,
ψ
)

∈

R
∘


 and


(
ϑ
,
χ
)

∈

R
∘


, that is,

φ
≢
ψ
∈
b

 and

ϑ
≢
χ
∈
b

. Then, by the completion condition Cpl(

≡
≡

), we have

(
φ
≡
ϑ
)
≢
(
ψ
≡
χ
)
∈
b

, that is,


(

(
φ
≡
ϑ
)

,

(
ψ
≡
χ
)

)

∈

R
∘


, so

R
∘

 is compatible with ≡, which ends the proof. □Let

p
∈
V

 and let

φ
,
ψ

 be
SCI
-formulas. We define the depth of an
SCI
-formula as follows:

d
(
p
)
=
d
(
φ
≡
ψ
)
=
0



d
(
¬
φ
)
=
d
(
φ
)
+
1



d
(
φ
→
ψ
)
=
max
(
d
(
φ
)
,
d
(
ψ
)
)
+
1

.By

FOR
n

, we denote the set of all
SCI
-formulas of depth n. Given an
SCI
-formula
φ
, by


[
φ
]


R
∘


 we denote the equivalence class of

R
∘

 determined by
φ
. Let b be an open branch of a

DT
SCI
*

-proof tree and let


M
b

=

(

U
b

,


∼

b

,

⇒
b

,

∘
b

,

D
b

)


 be the branch structure defined as follows:


U
b

=

{


[
φ
]


R
∘


:
φ
∈
FOR
}


,


D
b

=

{


[
φ
]


R
∘


:
φ
∈

⋃

n
∈
N



D
n

}


, where



D
0

=

{
φ
∈

FOR
0

:
¬
φ
∈
b
}


,


D

n
+
1


=

D

n
+
1

1

∪

D

n
+
1

2


, for


D

n
+
1

1

=

{
¬
φ
∈

FOR

n
+
1


:
φ
∉

D
n

}





D

n
+
1

2

=

{
φ
→
ψ
∈

FOR

n
+
1


:
φ
∉

⋃

k
≤
n



D
k


o
r

ψ
∈

⋃

k
≤
n



D
k

)


}


,operations

∼
b

,

⇒
b

,

∘
b

 are defined as:



∼

b



[
φ
]


R
∘



=
df



[
¬
φ
]


R
∘







[
φ
]


R
∘



⇒
b



[
ψ
]


R
∘



=
df



[
φ
→
ψ
]


R
∘







[
φ
]


R
∘



∘
b



[
ψ
]


R
∘


=

=
df



[
φ
≡
ψ
]


R
∘



.Proposition 8 (Branch Model Property). For every open branch b of a

DT
SCI
*

-proof tree, the branch structure

M
b

 is an
SCI
-model.Proof.  Let b be an open branch of a

DT
SCI
*

-proof tree. Clearly,

U
b

 is not empty. Observe also that, for every formula

φ
∈

FOR
n


, it holds that

φ
∈

⋃

n
∈
N



D
n


 iff

φ
∈

D
n


. Hence, for every formula

φ
∈

FOR
n


,



[
φ
]


R
∘


∈

D
b


 iff

φ
∈

D
n


. Moreover, by the completion condition Cpl(
ref
), for every
SCI
-formula
φ
,

φ
≢
φ
∈
b

, which means that

φ
≡
φ
∈

D
0


, and so



[
φ
≡
φ
]


R
∘


∈

D
b


. Thus,


D
b

≠
∅

. Now, as

φ
≡
φ
∈

D
0


 and

φ
≢
φ
∈

FOR
1


, by the definition of

D
n

,

φ
≢
φ
∉

D
1


, and so



[
φ
≢
φ
]


R
∘


∉

D
b


. Thus,


U
b

∖

D
b

≠
∅

.Due to Proposition 7, operations

∼
b

,

⇒
b

, and

∘
b

 are well defined. Indeed, assume



[
φ
]


R
∘


=


[
ψ
]


R
∘



, that is,


(
φ
,
ψ
)

∈

R
∘


. Then, by Proposition 7,


(
¬
φ
,
¬
ψ
)

∈

R
∘


, and so



[
¬
φ
]


R
∘


=


[
¬
ψ
]


R
∘



. Thus, since


∼
b



[
φ
]


R
∘


=


[
¬
φ
]


R
∘



 and


∼
b



[
ψ
]


R
∘


=


[
¬
ψ
]


R
∘



, we get


∼
b



[
φ
]


R
∘


=

∼
b



[
ψ
]


R
∘



. Therefore, if



[
φ
]


R
∘


=


[
ψ
]


R
∘



, then


∼
b



[
φ
]


R
∘


=

∼
b



[
ψ
]


R
∘



. Now, let

#
∈
{
→
,
≡
}

 and let

#
b

 be defined as:


#
b

=

⇒
b


, if

#
=
→

; and


#
b

=

∘
b


 otherwise. Assume



[
φ
]


R
∘


=


[
ψ
]


R
∘



 and



[
ϑ
]


R
∘


=


[
χ
]


R
∘



, that is,


(
φ
,
ψ
)

∈

R
∘


 and


(
ϑ
,
χ
)

∈

R
∘


. By Proposition 7, we obtain that


(

(
φ
#
ϑ
)

,

(
ψ
#
χ
)

)

∈

R
∘


, and so



[
φ
#
ϑ
]


R
∘


=


[
ψ
#
χ
]


R
∘



. Therefore, we have:




[
φ
]


R
∘



#
b



[
ϑ
]


R
∘


=


[
φ
#
ϑ
]


R
∘


=


[
ψ
#
χ
]


R
∘


=


[
ψ
]


R
∘



#
b



[
χ
]


R
∘


.


Hence, operations

∼
b

,

⇒
b

, and

∘
b

 are well defined. Now, we will prove that they satisfy semantic conditions with respect to

D
b

. Note that

D
b

 satisfy the following properties for every
SCI
-formula
φ
 and for all

n
,
k
∈
N

:
(*)If

d
(
φ
)
=
n

, then



[
φ
]


R
∘


∈

D
b


 iff

φ
∈

D
n


.(**)If

φ
∈

D
n


, then

d
(
φ
)
=
n

.(***)If

d
(
φ
)
=
n

 and

k
≠
n

, then

φ
∉

D
k


.Let



[
φ
]


R
∘


∈

U
b


 be such that

d
(
φ
)
=
n

, for some

n
∈
N

. Assume


∼
b



[
φ
]


R
∘


∈

D
b


, which by the definition of the operation

∼
b

 means that



[
¬
φ
]


R
∘


∈

D
b


. Thus, since

d
(
¬
φ
)
=
n
+
1

, by (*), we have

¬
φ
∈

D

n
+
1



. Then, by the definition of

D
b

, it holds that

φ
∉

D
n


, and thus due to (*) we obtain that



[
φ
]


R
∘


∉

D
b


. Now, assume that



[
φ
]


R
∘


∉

D
b


, that is, by (*), we obtain

φ
∉

D
n


. Thus, by the definition of

D
b

, we get

¬
φ
∈

D

n
+
1



, which due to (*) means that



[
¬
φ
]


R
∘


∈

D
b


. Hence, by the definition of the operation

∼
b

, we have


∼
b



[
φ
]


R
∘


∈

D
b


. Therefore, we have proved that


∼
b



[
φ
]


R
∘


∈

D
b


 iff



[
φ
]


R
∘


∉

D
b


.Let



[
φ
]


R
∘


,


[
ψ
]


R
∘


∈

U
b


. Assume



[
φ
]


R
∘



⇒
b



[
ψ
]


R
∘


∈

D
b


. Then, by the definition of

⇒
b

,



[
φ
→
ψ
]


R
∘


∈

D
b


. By the definition of

D
b

, there exists

n
∈
N

 such that

φ
→
ψ
∈

D
n


, which, by (**), implies

d
(
φ
→
ψ
)
=
n

, and clearly

n
≥
1

. Since

φ
→
ψ
∈

D
n


, by the definition of

D
b

, we obtain that either

φ
∉

⋃

k
<
n



D
k


 or

ψ
∈

⋃

k
<
n



D
k


. Clearly,

d
(
φ
)
<
n

, so, if

φ
∉

⋃

k
<
n



D
k


, then, due to (*), we get



[
φ
]


R
∘


∉

D
b


. Moreover,

d
(
ψ
)
<
n

, so, if

ψ
∈

⋃

k
<
n



D
k


, then, by (*), it holds that



[
ψ
]


R
∘


∈

D
b


. Hence, we have proved that, if



[
φ
]


R
∘



⇒
b



[
ψ
]


R
∘


∈

D
b


, then either



[
φ
]


R
∘


∉

D
b


 or



[
ψ
]


R
∘


∈

D
b


. Now, let us assume that

d
(
φ
)
=
i

,

d
(
ψ
)
=
j

, for some

i
,
j
∈
N

, and either



[
φ
]


R
∘


∉

D
b


 or



[
ψ
]


R
∘


∈

D
b


. Thus, by (**),

φ
∉

D
i


 or

ψ
∈

D
j


. Let

n
=
max
(
i
,
j
)
+
1

. If

φ
∉

D
i


, then, by (***), it can be easily proved that

φ
∉

⋃

k
<
n



D
k


. If

ψ
∈

D
j


, then, by (*),

ψ
∈

⋃

k
<
n



D
k


. Therefore, either

φ
∉

⋃

k
<
n



D
k


 or

ψ
∈

⋃

k
<
n



D
k


. Then, by the definition of

D
b

, it follows that

φ
→
ψ
∈

D
n


, and, by (*), we have



[
φ
→
ψ
]


R
∘


∈

D
b


. Thus, by the definition of the operation

⇒
b

, we obtain that



[
φ
]


R
∘



⇒
b



[
ψ
]


R
∘


∈

D
b


. Hence, we have proved that



[
φ
]


R
∘



⇒
b



[
ψ
]


R
∘


∈

D
b


 iff either



[
φ
]


R
∘


∉

D
b


 or



[
ψ
]


R
∘


∈

D
b


.Now, let



[
φ
]


R
∘


,


[
ψ
]


R
∘


∈

U
b


. Clearly,

d
(
φ
≡
ψ
)
=
0

. Then, the following can be easily shown:



[
φ
]


R
∘



∘
b



[
ψ
]


R
∘


∈

D
b


 iff



[
φ
≡
ψ
]


R
∘


∈

D
b


 iff

φ
≡
ψ
∈

D
0


 iff

φ
≢
ψ
∈
b

 iff


(
φ
,
ψ
)

∈

R
∘


 iff



[
φ
]


R
∘


=


[
ψ
]


R
∘



.Hence, we have shown that



[
φ
]


R
∘



∘
b



[
ψ
]


R
∘


∈

D
b


 iff



[
φ
]


R
∘


=


[
ψ
]


R
∘



. Therefore, we have proved that the branch structure

M
b

 is an
SCI
-model. □Let


M
b

=

(

U
b

,

∼
b

,

⇒
b

,

∘
b

,

D
b

)


 be the branch structure for an open branch b of a

DT
SCI
*

-proof tree. Let


v
b

:
FOR
→

U
b


 be a function such that


v
b


(
φ
)

=


[
φ
]


R
∘



, for all

φ
∈
FOR

. Due to the definition of

M
b

, the following can be easily proved:Proposition 9. Let b be an open branch of a

DT
SCI
*

-proof tree and let


M
b

=

(

U
b

,

∼
b

,

⇒
b

,

∘
b

,

D
b

)


 be the branch structure. Then, the function


v
b

:
FOR
→

U
b


 such that


v
b


(
φ
)

=


[
φ
]


R
∘



, for all

φ
∈
FOR

, is an
SCI
-valuation in

M
b

, that is, for all
SCI
-formulas φ and ψ, the following hold:


v
b


(
¬
φ
)

=

∼
b



[
φ
]


R
∘






v
b


(
φ
→
ψ
)

=


[
φ
]


R
∘



⇒
b



[
ψ
]


R
∘






v
b


(
φ
≡
ψ
)

=


[
φ
]


R
∘



∘
b



[
ψ
]


R
∘



.The valuation

v
b

 will be referred to as the branch valuation. Now, we will prove the property that will enable us to prove the completeness theorem.Proposition 10 (Satisfaction in Branch Model Property). Let


M
b

=

(

U
b

,

∼
b

,

⇒
b

,

∘
b

,

D
b

)


 be the branch structure for an open branch b of a

DT
SCI
*

-proof tree and let

v
b

 be the branch valuation in

M
b

. Then, for every
SCI
-formula φ, if


M
b

,

v
b

⊨
φ

, then

φ
∉
b

.Proof.  Let


M
b

=

(

U
b

,

∼
b

,

⇒
b

,

∘
b

,

D
b

)


 be the branch structure for an open branch b of a

DT
SCI
*

-proof tree and

v
b

 the branch valuation in

M
b

. We will prove the proposition by the induction on the depth of
SCI
-formulas. Let
φ
 be an
SCI
-formula such that

d
(
φ
)
=
0

.Assume


M
b

,

v
b

⊨
φ

. Note that the following holds:


M
b

,

v
b

⊨
φ

 iff


v
b


(
φ
)

=


[
φ
]


R
∘


∈

D
b


 iff

φ
∈

D
0


 iff

¬
φ
∈
b

. Thus, by the assumption, we obtain

¬
φ
∈
b

, which, by Proposition 5, implies

φ
∉
b

.Assume


M
b

,

v
b

⊨
¬
φ

. Then,


M
b

,

v
b

⊨
¬
φ

 iff


v
b


(
¬
φ
)

=


[
¬
φ
]


R
∘


∈

D
b


 iff

¬
φ
∈

D
1


. Suppose

¬
φ
∈
b

. Then,

φ
∈

D
0


, so, by the definition of

D
1

, we have

¬
φ
∉

D
1


, a contradiction.Assume that the proposition holds for
SCI
-formulas
φ
 and
ψ
 and their negations. We will show that it holds for formulas

¬
¬
φ

,

φ
→
ψ

, and

¬
(
φ
→
ψ
)

.Let


M
b

,

v
b

⊨
¬
¬
φ

. Since

M
b

 is an
SCI
-model, by the assumption


M
b

,

v
b

⊨
φ

. Thus, by the inductive hypothesis,

φ
∉
b

. Suppose

¬
¬
φ
∈
b

. Then, by the completion condition Cpl(¬),

φ
∈
b

, a contradiction.Let


M
b

,

v
b

⊨
φ
→
ψ

. Then, either


M
b

,

v
b

⊨
¬
φ

 or


M
b

,

v
b

⊨
ψ

. Then, by the inductive hypothesis, either

¬
φ
∉
b

 or

ψ
∉
b

. Suppose

φ
→
ψ
∈
b

. Then, by the completion condition Cpl(→), both

¬
φ
∈
b

 and

ψ
∈
b

, a contradiction.Let


M
b

,

v
b

⊨
¬

(
φ
→
ψ
)


. Then, both


M
b

,

v
b

⊨
φ

 and


M
b

,

v
b

⊨
¬
ψ

. Then, by the inductive hypothesis, both

φ
∉
b

 and

¬
ψ
∉
b

. Suppose

¬
(
φ
→
ψ
)
∈
b

. Then, by the completion condition Cpl(

¬

→

), either

φ
∈
b

 or

¬
ψ
∈
b

, a contradiction. □Now, we will prove completeness of an

DT
SCI
*

-system:Theorem 6 (Completeness of

DT
SCI
*

). If an
SCI
-formula is
SCI
-valid, then it is

DT
SCI
*

-provable.Proof.  Let
φ
 be
SCI
-valid and suppose that a closed

DT
SCI
*

-proof tree for
φ
 does not exist. Then, there exists a complete

DT
SCI
*

-proof tree for
φ
 with an open branch, say b. Clearly,

φ
∈
b

, so by Proposition 10, the branch structure

M
b

 and the branch valuation

v
b

 do not satisfy
φ
. However, by Proposition 8,

M
b

 is an
SCI
-model. Thus,
φ
 is not true in some
SCI
-model, and hence
φ
 is not
SCI
-valid, a contradiction. □Theorems 5 and 6 imply:Theorem 7 (Soundness and Completeness of

DT
SCI
*

). Let φ be an
SCI
-formula. Then, the following conditions are equivalent:1.φ is
SCI
-valid;2.φ is

DT
SCI
*

-provable.Below, we present examples of

DT
SCI
*

-proofs, namely

DT
SCI
*

-proofs of


(

p
1

≡

p
2

)

→

(

p
1

→

p
2

)


 and


(

p
1

≡

p
2

)

→

[

(

p
2

≡

p
3

)

→

(

p
1

≡

p
3

)

]


 are presented in Figure 5 and Figure 6, respectively. Note that

DT
SCI
*

-proofs are much shorter than the corresponding proofs of these formulas in the systems

G
SCI

 and

DT
SCI

. Furthermore, contrary to the proofs in

G
SCI

 and

DT
SCI

,

DT
SCI
*

-proofs of formulas in question are one-branching proofs. 6. DiscussionAll the systems presented in the previous sections are sound and complete deduction systems for
SCI
. Comparing with systems

G
SCI

 and

DT
SCI

, the system

DT
SCI
*

 seems to be simpler, more intuitive, and more effective. Its rules for the identity connective do not split a branch of a tree and do not make use of substitution. It should also be emphasized that the only rule of

DT
SCI
*

-system that may introduce branching is the rule

(
¬

→
)

. Furthermore, although

DT
SCI
*

 contains nine rules, while

G
SCI

-system has 12 rules,

DT
SCI
*

-system generates proofs that are much simpler and shorter than corresponding proofs in

G
SCI

.However, all the systems presented in this paper have one important disadvantage. The logic
SCI
 is decidable, while the systems in question are not decision procedures for
SCI
 as, in particular, they may generate infinite trees. Although there is a decision procedure for
SCI
 based on

G
SCI

-system, as shown in [13], but a procedure described in [13] contains external machinery that is not a part of the system itself, so it provides rather another proof for decidability of
SCI
 than a decision procedure itself. Hence, further research on deduction systems for
SCI
 should focus on seeking its decision procedure. The system

DT
SCI
*

 seems to have a significant advantage over other systems

G
SCI

 and

DT
SCI

, as its relatively simple modification could provide a decision procedure for
SCI
. A possible modification of

DT
SCI
*

 should restrict applicability of the rules for the identity connective as follows: (1) the rule

(
ref
)

 can be applied only for
φ
 that are subformulas or negated subformulas of the initial formula; (2) given the formulas
φ
,
ψ
,
ϑ
, the rules

(
sym
)

 and

(
tran
)

 can be applied only once; (3) the rules

(

≡
¬

)

,

(

≡
→

)

, and

(

≡
≡

)

 can be applied to a finite set of formulas provided that the length of new formulas introduced by rules is not greater than the length of the initial formula plus 1. Additionally, we should also impose a general restriction on closeness of a branch, namely that, if a node is a ‘copy’ of some earlier node, then the branch is closed. It seems that such a modification could guarantee termination of proof trees, and thus it could provide a decision procedure for
SCI
. 7. ConclusionsWe have presented and discussed two types of systems for
SCI
 known from the literature: sequent calculus

G
SCI

 and a dual tableau-like system

DT
SCI

. Then, we presented the system

DT
SCI
*

, which is a new dual tableau system for the logic
SCI
. We proved soundness and completeness of

DT
SCI
*

 and we showed that it is more efficient than

G
SCI

 and

DT
SCI

: it does not involve any substitution rule, its rules for the identity connective do not branch a proof tree, and it generates shorter and simpler proof trees. Further research on deduction systems for non-Fregean logics should concentrate on decision procedures for
SCI
 and a methodology of designing deduction systems in tableuax style for non-Fregean logics which are extensions and modifications of
SCI
.
