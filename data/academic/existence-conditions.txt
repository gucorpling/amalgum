 1. IntroductionRecently, the use of serial robots has increased owing to their extensive application in the field of bionics and in various industries [1,2,3,4,5]. Overcoming the usual problems in inverse kinematics is a key to controlling the motion of serial robots. However, inverse kinematics is a non-linear problem with multiple solutions. Among these solutions, the general numerical solution method is both time-consuming and unstable. Alternatively, the closed-form solution for inverse kinematics is commonly sought for practical applications but has two major limitations that remain unsolved. First, there is no general method for finding the closed-form solution. Second, the Pieper criterion is not complete.To resolve these problems, a model for the robotic kinematics needs to be established. There are two major methods for robotic modeling using inverse kinematics, namely the Denavit–Hartenberg (DH) parametric method and the product of exponentials (POE) formula method.The DH parametric modeling method is based on a transformation of coordinates [6]. Due to its easily visualized parameters, this convenient method has attracted the attention of many researchers and engineers. Under this model, the inverse kinematics problem is solved via two methods, i.e., numerical and closed-form solutions. Moreover, because the forward kinematics formula of the DH model provides a maximum of six independent equations, simplifying the algebraic equation using the numerical method can solve the inverse kinematics problem for most non-redundant robots [7]. In addition, the Jacobian matrix derived in the DH model can be used to solve the inverse kinematics problem for redundant robots [6,8,9,10,11]. Based on the numerical method, a series of objective functions can be added [12] that not only enable the robot to reach a designated position but also allow the completion of some extra tasks, such as keeping away from a singular point or maintaining its maximum motion ability. Studies on numerical solutions have primarily focused on efficiently and stably solving the equations or obtaining an approximate solution using the functional approximation method in combination with neural networks and intelligent algorithms [11,13,14]. However, owing to the existence of the robotic singular posture, the stability of the numerical solution and its convergence rate cannot be guaranteed. Therefore, this method is not suitable for cases where instantaneity is required.Another method based on the DH model is the analytical method, which uses a closed formula to determine the relations between the terminal posture and various joint angles. Nonetheless, not all robots have a closed-form solution. In 1978, a general method for solving for the closed-form solution was proposed by Paul [15]. In 1968, Pieper studied six-degree-of-freedom (DOF) robots with three axes intersecting at one point [16] and concluded that a serial robot with the three terminal axes intersecting at one point has a closed-form solution. This criterion, i.e., that a six-DOF serial robot with three terminal axes intersecting at one point (defined as Pieper Criterion 1, let us say PC-1) or three adjacent parallel axes (defined as Pieper Criterion 2, let us say PC-2) has a closed-form solution, has been obtained in subsequent studies [17,18]. However, the method proposed by Paul needs to be manually derived and the formula needs to be rederived every time the robot structure changes, which limits the universality of the closed-form solution. Accordingly, studies on the closed-form solution based on the DH model have primarily focused on situations with already known structures, such as keeping the robot away from a singular value [19]. More importantly, the necessary conditions for the existence of the closed-form inverse solution given by Pieper are inadequate. For example, a robot with the DH parameters listed in Table 1 has three terminal axes intersecting at one point, as well as three parallel joints; however, its inverse kinematics problem cannot be solved.The DH method is a parameter selection norm based on a transformation of coordinates [6]. This method regulates the criterion for selecting three parameters between two adjacent axes, where

a

 represents the linkage offset, i.e., the normal offset between the two adjacent axes,

d

 is the linkage length, representing the axial offset between the two adjacent axes, and

α

 is the linkage torsion, representing the included angle between the two adjacent axes.On a similar note, the robot with the DH parameters listed in Table 2 has three adjacent and parallel joints; however, we cannot solve the inverse kinematics problem.The inadequacy of the Pieper principle leads to defects in the inverse kinematics algorithm designed on the basis of this principle. However, no further studies on this problem have been conducted to supplement and improve this method.Conversely, the modeling method for the POE formula has been presented in some detail [20]. The logic for the inverse kinematics solution problem based on POE primarily consists of a reduction of the original problem into several sub-problems followed by solving all the joint angles step by step. This method uses an abstract geometric model to solve the inverse kinematics problem, therefore enhancing the generalization of the algorithm. In POE-based studies, several universal inverse kinematics algorithms have been designed, of which the most typical universal sub-problem was proposed in 1986 [21,22]. There is subproblem 1. Rotation about a single axis, subproblem 2. Rotation about two subsequent axes, and subproblem 3. Rotation to a given distance. A robotic universal solving method that meets the Pieper principle has been proposed [23], and a new sub-problem was proposed to solve the universal inverse kinematics algorithm [24]. The universal inverse kinematics algorithm based on the POE model has definite geometrical significance and stable numerical values. However, in practice, it is impossible for some robots to utilize the known sub-problems to describe and solve the problem. In addition, the algorithm consumes enormous computational resources when selecting sub-problems. As a result, it is difficult for the universal inverse solution algorithm based on the POE model to be applied in cases with real-time requirements.It can be seen that both the DH model and POE model have various drawbacks in solving inverse kinematics problems. This study proposes a method for judging the existence of closed-form solutions based on the DH model to deal with the first problem of the closed-form solution. In this method, revolute serial robots with closed-form solutions are described using three types of sub-problems from the viewpoint of solving the algebraic equations. They are sub-problem of translation components, sub-problem of rotational components, and sub-problem of sub-chains. In more detail, based on sub-problems, when the configuration of the robot satisfies some characteristics, some more concise and fixed formulas can be used to solve the joint angle. This article refers to this more specific situation as the basic problem of sub-problems, a total of ten. If a serial robot can be described using the three types of sub-problems, i.e., if the inverse motion problems can be solved by several basic problems, then there is a closed-form solution. Based on the above method, a set of universal closed-form inverse kinematics solving algorithms is designed to address the second problem mentioned above. Since there is a definite formula solution in the three types of sub-problems, the joint angles can be rapidly determined. In addition, because the DH parameters can directly reflect the linkage of the robot, the judgment of the sub-problems is also quick and accurate.In general, the main contributions of this article are: Proposes a more complete judgment condition for the existence of the closed-form solution of series robot to solve the defect of Pieper principle. In addition, this judgment method is a method that is suitable for all robots whose degree of freedom is less than six.A general inverse kinematics algorithm is designed for this judgment method. We can use this algorithm to find the angles of all joints of the series robots meet the conditions quickly and accurately.This universal inverse solution algorithm has a simple judgment method, the calculation speed of it is fast, and it is an algorithm that can be applied in occasions with real-time requirements. Usually, a special method is used for the motion control of series robot, only the common configuration is supported, and some parameters cannot be adjusted. Therefore, the proposed method can greatly improve the application range of the motion controller of series robots.Proposed method and theory has also enriched the foundation of robotics.The manuscript is organized as follows. Section 2 derives a kinematics equation for a robot based on the standard DH model. Relevant properties are obtained according to the forward kinematics equation to be used in the inverse kinematics problems. Section 3 analyzes the robotic inverse kinematics problems. According to the existence conditions, the inverse kinematics problems are divided into three sub-problems and 10 types of basic problems. Section 4 designs a universal inverse kinematics algorithm. Section 5 designed two experiments. The first experiment uses MATLAB and Robotics Toolbox [25] to test the completeness, versatility, and continuity of the algorithm. Subsequently, the algorithm is implemented and verified in a real-time system to demonstrate its correctness and real-time stability. Section 6 presents a summary of the findings of this paper. 2. Kinetic Models 2.1. Standard DH ParametersThe DH method is a parameter selection norm based on a transformation of coordinates [6].Let axis

k

 denote the axis of the axis connecting link


k
−
1


 to link

k

; DH method adopted to define link Frame

k

:Choose axis



z
k



 along the axis of joint


k
+
1


. Locate the origin



O
k



 at the intersection of axis



z
k



 with the common normal to axes



z

k
−
1




 and



z
k



. Locate also



O

k
′




 at the intersection of the common normal with axis



z

k
−
1




. Choose axis



x
k



 along the common normal to axes



z

k
−
1




 and



z
k



 with direction from joint

k

 to joint


k
+
1


. Choose axis



y
k



 so as to complete a right-handed frame.Once the link frames have been established, the position and orientation of Frame

k

 with respect to Frame


k
−
1


 are completely specified by the following parameters:



a
k



 distance between



O
k



 and



O

k
′








d
k



 coordinate of



O

k
′




 along



z

k
−
1




,



α
i



 angle between axes



z

k
−
1




 and



z
k



 about axis



x
k



 to be taken positive when rotation is made counter-clockwise, and



θ
k



 angle between axes



x

k
−
1




 and



x
k



 about axis



z

k
−
1




 to be taken positive when rotation is made counter-clockwise.Using the DH method, the relations for a robot can be directly established in a visualized manner and the existence conditions for closed-form solutions can be derived in a more direct and visualized manner. The standard DH parameters in the case of the KingKong collaborative robot are shown in Table 3. A schematic diagram of the robot is shown in Figure 1. 2.2. Forward Kinematics FormulaUsing the following formula, the DH parameters [6] can be transformed into elements of a transformation matrix from [6]:





T



k

k
−
1



(


θ
i


)

=

[






R
k






P
k








0

1
×
3





1




]

=

[





c
o
s

θ
k





−
s
i
n

θ
k

c
o
s

α
k





s
i
n

θ
k

s
i
n

α
k






a
k

c
o
s

θ
k







s
i
n

θ
k





c
o
s

θ
k

c
o
s

α
k





−
c
o
s

θ
k

s
i
n

α
k






a
k

s
i
n

θ
k






0



s
i
n

α
k





c
o
s

α
k






d
k






0


0


0


1




]

,





(1)


where


k


 indicates the number of the current joint.



R



k

k
−
1




 is the rotational component of



T



k

k
−
1



(


θ
k


)



, a 3 × 3 orthogonal matrix, and



P



k

k
−
1




 is the translational component of



T



k

k
−
1



(


θ
k


)



. The end transformation matrix of the end executor of the robot relative to the coordinate system can be obtained using the following formula:





T



i
0

=

T



1
0


T



2
1


T



3
2

⋯

T



i

i
−
1


.





(2)



i

 indicates the number of degrees of freedoms of the robot. According to Equation (2) from [18], we could obtain



T



i
0



 as follows:





T



i
0

=

[






R



i
0






P



i
0








0

1
×
3





1




]

=

[







∏

n
=
1


n
=
i




R



n

n
−
1








∑

n
=
1


n
=
i




R



1
0

…

P



i

i
−
1









0

1
×
3





1




]

,





(3)


where



R



i
0



 is the rotational component of



T



i
0



. Since the rotational component



R



i

i
−
1




 is closed and orthogonal,



R



i
0



 is an orthogonal matrix. Here,



P



i
0



 is the translational component of



T



i
0



, which can be represented as follows:





P



i
0

=


∑

n
=
1


n
=
i




R



1
0

…

P



i

i
−
1


=


∑

n
=
1


n
=
i




P
n

.





(4)

According to Equation (4), the positional component of the back linkage is influenced by the front joint angle.In the definition of the DH parameter, the Z-direction of the joint coordinate indicates the orientation of the joint and can be used to characterize the relationship between the joints. Here, the joints of the serial robots are represented as



z
k



. To concisely indicate the linkage relations, the following definitions are made:



α
k

=
0


, then



z
k

∥

z

k
+
1




, whereas



α
k

=
±
π
/
2


, then



z
k

⊥

z

k
+
1




, where



z
k

a
,
d




 represents the linkage parameters



a
k

=

d
k

=
0


. 2.3. Decoupling of the End LinkageThe coordinate transformation matrix is written as



T




i
−
1

0

=

[






R




i
−
1

0






P




i
−
1

0








0

1
×
3





1




]



. Moreover, the transformation matrix of the last axis is



T



i

i
−
1


=

[






R



i

i
−
1







P



i

i
−
1









0

1
×
3





1




]



. The rotational component

R

 is written in the form of a row vector as


R
=

[





x
→




y
→




z
→





]



.Then,



P



i
0



 can be written as:





P



i
0

=

R




i
−
1

0


[





c
o
s

θ
i







s
i
n

θ
i






0




]


a
i

+


z
→





i
−
1

0


d
i

+

P




i
−
1

0

,





(5)


further:





R




i
−
1

0


[





c
o
s

θ
i







s
i
n

θ
i






0




]

=


x
→




i
0

.





(6)

The following conclusions can be drawn: when



α
i

=
π
/
2


 then




y
→




i
0

=


z
→





i
−
1

0



,






P




i
−
1

0

=

P



i
0

−


x
→




i
0


a
i

−


y
→




i
0


d
i

;





(7)

when



α
i

=
−
π
/
2


 then




y
→




i
0

=
−


z
→





i
−
1

0



,






P




i
−
1

0

=

P



i
0

−


x
→




i
0


a
i

+


y
→




i
0


d
i

;





(8)

and when



α
i

=
0


 then,




z
→




i
0

=


z
→





i
−
1

0



,






P




i
−
1

0

=

P



i
0

−


x
→




i
0


a
i

−


z
→




i
0


d
i

.





(9)

The above derivation demonstrates that when the current end transformation matrix



T



i
0



 is known, the translational component



P




i
−
1

0



 in the previous transformational matrix



T




i
−
1

0



 can be obtained based on the rotational component



R



i
0



 of



T



i
0



 and the translational component



P



i
0



. Given such a property, the last axis may not be considered when the translational component of the robot is being analyzed. 2.4. Translational Relation of the Rotational ComponentAccording to Equation (3) form [6],



R



k

k
−
1


=
Rotz

(


θ
k


)

Rotx

(


α
k


)

.


 The rotational component of the transformational matrix can be expressed as:





R



k
0

=

∏

n
=
1


n
=
k



R



n

n
−
1


=

∏

n
=
1


n
=
k


Rotz

(


θ
n


)

Rotx

(


α
n


)

.





(10)

If there exists several continuous parallel joints in the robot, then



z
l

∥

z

l
+
1


…
∥

z
m



 and



α
l

=

α

l
+
1


…
=

α

m
−
1


=
0


. In addition, the rotational transformation in the same direction has additivity:





R



m
l

=


∏


n
=
l


n
=
m


Rotz

(


θ
n


)

Rotx

(


α
n


)

=
Rotz

(
Θ
)

Rotx

(


α
m


)

=

R


θ
s



,





(11)


where


Θ
=

θ
l

+

θ

l
+
1


…
+

θ
m



. Here, we refer to



z
l

∥

z

l
+
1


…
∥

z
m



 as a sub-chain

s

. This concept will be used in the following paragraphs. According to Equation (11), the translational components of the sub-chain



z
1

∥

z
2

…
∥

z
m



 can be defined and simplified as follows:





P



m

m
−
1


=

R

1
.
m
−
1



P
m

=
R
o
t
z

(
Θ
)


[






a
m






0




0




]

+

[




0




0






d
m






]

=

[






a
m

cos
 
Θ







a
m

sin
 
Θ







d
m






]

=

P


θ
s



,





(12)


where


Θ
=

θ
1

+

θ
2

…
+

θ
m



.



R


θ
s





 defined by the formula (11) and



P


θ
s





 defined by the formula (12), will be used in the following paragraphs. 2.5. Solving the Trigonometric EquationThis section summarizes two common formula solutions for trigonometric functions. The first can be derived using Equation (4):





P



i
0

=

P



1
0

+

R



1
0



∑

n
=
2


n
=
i




R



2
1

⋯

P



n

n
−
1


=

[






(


P



i
1



y

s
i
n

α
1

−

n
1


P



i
1



x


)

s
i
n

θ
1

+

(


P



i
1



z


a
1

+

a
1


)

c
o
s

θ
1








(


P



i
1



z


a
1

+

a
1


)

s
i
n

θ
1

−

(


n
1


P



i
1




y

−

n
1


P



i
1




x


)

c
o
s

θ
1







s
i
n

α
1


P



i
1




x

+

n
1


P



i
1




y

+

(

1
+

P



i
1




z


)


d
1






]

,





(13)


where



P



i
1



x

,

P



i
1



y

,


 and



P



i
1



z



 represent the three components in



R



1
0




−
1



(


P



i
0

−

P



1
0


)



 and



n
i

=
s
i
g
n

(


α
i


)



. According to Equation (18),



P



i
0



x



,



P



i
0



y



, and



θ
1



 satisfy a special trigonometric function relation, as shown in Equation (14):





[






P



i
0



x








P



i
0



y






]

=

[




D


L




L



−
D





]


[





s
i
n

θ
1







c
o
s

θ
1






]

,

(

D
≠
0
 
o
r
 
L
≠
0

)

.





(14)

Therefore,






θ
1

=
a
t
a
n
2

(

D

P



i
0



x

+
L

P



i
0



y

,
L

P



i
0



x

−
D

P



i
0



y


)

.





(15)

Another common trigonometric equation is shown in Equation (16) from [17]:




A
c
o
s
θ
+
B
s
i
n
θ
=
C
,

(

A
≠
0
 
o
r
 
B
≠
0

)

,





(16)


whose solution is:




θ
=
2
a
t
a
n

(



B
±



B
2

+

A
2

−

C
2





A
+
C



)

.





(17)

Equations (15) and (17) can map the joint angles within the interval of



[

−
π
,

 
π


]



. Moreover, in the following paragraphs, the robotic inverse solution equation is transformed into Equations (14) and (16), resulting in a fixed formula, which can compute the equation parameters and further derive the common closed-form formula solution for serial robots. When the parameters for Equations (14) and (16) are zero, the equation has no solution. This provides a suitable answer to the question of whether a robot has a solution when the linkage parameters are sparse. For convenience, Equation (14) is represented as



θ
1

=

F
1


(

D
,
L
,
x
,
y

)



 and Equation (15) is represented as



θ

k
1


,

θ

k
2


=

F
2


(

A
,
B
,
C

)



. 3. Analysis of The Inverse Kinematics ProblemGiven a transformational matrix with a known end



T



i
0

=

[






R



i
0






P



i
0








0

1
×
3





1




]



, the joint angle is obtained inversely from the equation provided by



R



i
0



 and



P



i
0



; this is known as inverse kinematics. 3.1. Three Types of Sub-Problems Related to Closed-Form Inverse KinematicsThe French mathematician Évariste Galois proved that the quartic polynomial equation has a closed-form solution, whereas the sextic polynomial equation generally has none. The rotational and translational components of the robotic end transformational matrix provide three independent equations separately. The two equation sets are combined to solve the inverse kinematics problem, and then high-order polynomial equations may be required. Therefore, a robot has a closed-form inverse solution, partial joint angles will be preferably solved from a certain equation set followed by the other joint angles.To guarantee the existence of a closed-form solution, a feasible solution guarantees mutual decoupling between the translational and rotational components [17,26]. Such traditional decoupling enables the translational component to be associated with the front three joints, which in turn, are solved via



P



3
0

.


 The latter three joints are solved via the rotational component



R



6
3



.






T



6
0

=

[






R



3
0






P



3
0






0


1




]


[






R



6
3




0




0


1




]

=

[






R



3
0


R



6
3






P



3
0






0


1




]

.





(18)

Based on the derivation in Section 2.4, a robot has several parallel joints, the number of unknown numbers in the rotational component will decrease. Therefore, another feasible decoupling idea is to preferably find a solution using the rotational component



R



6
0


(

φ
,
ϑ
,
ψ

)



 and solve for the remaining joint angles using the translational component



P



6
0



. This strategy has not been mentioned in any previous studies.






T



6
0

=

[






R



6
0






P



6
0






0


1




]

=

[






R



6
0


(

φ
,
ϑ
,
ψ

)






P



6
0






0


1




]

.





(19)

Based on the above two decoupling methods, we could obtain three types of sub-problems.In the first type, when the number of unknowns in the rotational component is larger than three and the robot meets some structural characteristics, some joint angles can be preferably and directly solved using the translational component. This article refers to the first type sub-problem as the sub-problem of translation components.In the second type, the robot has several parallel joints and the number of unknowns in the rotational component is no greater than 3, these unknowns can be solved using the rotational component. This article refers to the second type sub-problem as sub-problem of rotational components.In the third and final type, when the second type is used to solve the unknowns for the robot and the joint angles are still not completely solved, the remaining joint angles are obtained using the translational component. This article refers to the third type sub-problem as a sub-problem of sub-chains.Via an analysis of these sub-problems, it is possible to determine the solving conditions and methods in detail. In Section 3.2, Section 3.3 and Section 3.4, a more detailed analysis and derivation will be made for each sub-problem, and the formulas and conditions for solving the basic problems will be obtained. 3.2. The First Type of Sub-problemWhen there exist more than three unknowns in the rotational component, the partial joint angles should preferably be solved using the translational component. With reference to the DH parameter table, the DOF of the robot is


i


 and the number of the DOF with


α
=
0


 in the first


i
−
1


 DOFs is

p

. In the case of


i
−
p
>
3


, there are more than three unknowns in the rotational component.According to Equation (4), the back joint angles are influenced by the front joint angles in the translational component. Therefore, the association with a maximum of the front three joint angles in the translational equation must be first guaranteed to solve the first type of sub-problem.When the first joint angle of the robot model


R
o
b
o

t
i



 with

i

 DOFs is solved,



T



1
0



 can be calculated using the forward kinematics formula. Meanwhile, the first row of the DH parameters is deleted to form a new robot model


R
o
b
o

t

i
−
1




 and a new transformational matrix



T




i
−
1

0



:





T



i
1

=

T



1
0




−
1



T



i
0

=

[






R



1
0




−
1






−

R



1
0




−
1



P



1
0








0

1
×
3





1




]


T



i
0

.





(20)

There may only be a parallel or vertical relationship between two adjacent joints. Since only the linkage relation of the front three axes is considered, the possible configuration between the first three axes is only the case where



C
2
1


C
2
1

=
4


. Moreover,



z
1

⊥

z
2

⊥

z
3



,



z
1

∥

z
2

⊥

z
3

,
 

z
1

⊥

z
2

∥

z
3


 
and
 


z
1

∥

z
2

∥

z
3



. However, during the process of derivation, it was found that



z
1

∥

z
2

∥

z
3



 only provides two valid equations in X-direction and Y-direction, making it impossible to solve for three unknowns:





P



3
0

=

[






a
3

c
o
s

(


θ
1

+

θ
2

+

θ
3


)

+

a
2

c
o
s

(


θ
1

+

θ
2


)

+

a
1

c
o
s

θ
1








a
3

s
i
n

(


θ
1

+

θ
2

+

θ
3


)

+

a
2


s
i
n


(


θ
1

+

θ
2


)

+

a
1

s
i
n

θ
1








d
1

+

d
2

+

d
3






]

.





(21)

Such a case is the counter example mentioned in the preceding paragraphs. The Piper principle does not specifically describe such a case. Therefore, the linkage parametric limitations and the formula solution for the three basic problems are derived in detail in the following paragraphs. 3.2.1. First Three Joint Configured as



z
1

∥

z
2

⊥

z
3
a



Here, the expression for the translational component is



P



3
0

=

P
1

+

R
1


P
2

+

R
1


R
2


P
3



. However,



R
1


R
2


P
3



 contains the cubic term of the sine and cosine functions, which would directly increase the order of the equation to sextic. Only when



a
3

=
0


 will the requirements for a closed solution be met. According to Equation (18), The formula solution of



θ
1



 can be obtained as follows:









θ

11


=

F
1


(

D
,
L
,

P



3
0



x

,

P



3
0



y


)








θ

12


=

F
1


(

D
,
−
L
,

P



3
0



x

,

P



3
0



y


)





,
 
where

{





D
=

n
1


d
2







L
=



P



3
0





x


2

+

P



3
0





y


2

−

D
2









.





(22)

Once



θ
1



 is obtained, the forward kinematics formula can be used to forward simplify the robot to obtain the expression of



T



i
1



 and the DOFs of


i
−
1


. The basic problem can still be employed to seek a solution to



θ
2



.To guarantee the existence of only the front two joint angles in the translational equation, the linkage of



z

k
>
3




 needs to satisfy


d
=
a
=
0


. However, according to the end decoupling formula proposed in Section 2.3, the linkage parameters of the last joint are not restricted. 3.2.2. First Three Joint Configured as



z
1

∥

z
2

⊥

z
3



The formula solution for



z
1

∥

z
2

⊥

z
3



 is derived in the following paragraphs. Its translational component can be written as



P



3
0

=

P
1

+

P

12


+

R

12



P
3



, and its translational equation can be arranged as follows:





[






a
1

c
o
s

θ
1

+
D
sin

(


θ
1

+

θ
2


)

+
L
cos

(


θ
1

+

θ
2


)








a
1

s
i
n

θ
1

+
L
sin

(


θ
1

+

θ
2


)

−
D
cos

(


θ
1

+

θ
2


)








n
2


a
3

s
i
n

θ
3






]

=

[










P



3
0



x








P



3
0



y












P



3
0



z

−

d
1

−

d
2






]

.





(23)

Arranging Equation (23) gives the formula solution Equation (24):








θ

31


,

θ

32


=

F
2


(


A
3

,

B
3

,

C
3


)

,
 
where

{






A
3

=
0







B
3

=

n
2


a
3








C
3

=

P



3
0



z

−

d
1

−

d
2







;







θ

11


,

θ

12


=

F
2


(


A
1

,

B
1

,

C
1


)

,
 
where

{






A
1

=

P



3
0




x








B
1

=

P



3
0




y







D
=

n
2


d
3







L
=

a
2

+

a
3

c
o
s

θ
3








C
1

=



P



3
0






x


2

+

P



3
0






y


2

+

a
1




2

−

L
2

−

D
2



2

a
1
















θ
1

+

θ
2

=

F
1


(

D
,
L
,



P



3
0




x


˜

,



P



3
0




y


˜


)

,
 
where

{








P



3
0




x


˜

=

P



3
0




x

−

a
1

c
o
s

θ
1










P



3
0




y


˜

=

P



3
0




y

−

a
1

s
i
n

θ
1







;







θ
2

=
f



[


(


θ
1

+

θ
2


)

−

θ
1


]



±
π


;








(24)


where


f



[
θ
]



±
π




 in the last equation indicates that

θ

 is mapped onto the interval of



[

−
π
,
π

]



.Under such a structure,



θ
3



 is preferably solved using the equation in the Z-direction. Therefore, the existence of



z
4
a



 after



z
3



 does not influence the solution of



θ
3



, resulting in the derivation of two different structures,



z
1

∥

z
2

⊥

z
3

⊥

z
4
a



 and



z
1

∥

z
2

⊥

z
3

∥

z
4
a



.According to the translational equation of



z
1

∥

z
2

⊥

z
3

⊥

z
4
a



 and Equation (23), the critical coefficient is:





{





D
=

n
2


d
3

+

n
2


d
4







L
=

a
2

+

a
3

cos

θ
3







.





(25)

Moreover, according to Equation (23), the critical coefficient under



z
1

∥

z
2

⊥

z
3

∥

z
4
a



 is:





A
3

=
−

n
2


n
3


d
4

,
 
where
 

{





D
=

n
2


d
3







L
=

a
2

+

a
3

cos

θ
3

+

n
3


d
4

sin

θ
3

.











(26)

To guarantee that only the front three joint angles exist in the translational equation, the linkage of



z

k
>
4




 needs to satisfy


d
=
a
=
0


. There is not restricted to the linkage parameters of the last joint.In addition, in the basic problems mentioned above, when



d
4

=

a
4

=
0


 is true in



z
4



, it can also be used to solve



z
1

∥

z
2

⊥

z
3



. Similarly, it can be used to solve



z
1

∥

z
2



. Therefore, such a type of basic problem contains two sets of formula solutions that can be used to solve four cases. 3.2.3. First Three Joint Configured as



z
1

⊥

z
2

∥

z
3



The solution method for



z
1

⊥

z
2

∥

z
3
a



 in Section 3.4.1 also applies here. In addition, if



z
1

⊥

z
2

∥

z
3

⊥

z
4
a



 and


D
=

n
1


(


d
2

+

d
3


)



,



θ
1



 can still be directly solved. This results in a special situation. Further, suppose there is a robot with

i

 degrees of freedom, in which the configuration of the first

g

 joints is



z
1

⊥

z
2

∥
…
∥

z

g
−
1


⊥

z
g
a



, and the linkage of



z

k
>
g




 needs to satisfy


d
=
a
=
0


. These are not restricted to the linkage parameters of the last joint. The formula solution of



θ
1



 can be obtained as follows:









θ

11


=

F
1


(

D
,
L
,

P



g
0



x

,

P



g
0



y


)








θ

12


=

F
1


(

D
,
−
L
,

P



g
0



x

,

P



g
0



y


)





,

 
where

 

{





D
=

n
1



∑

m
=
2


g
−
1




d
m







L
=
±



P



g
0





x


2

+

P



g
0





y


2

−

D
2









.





(27)

According to the forward kinematics formula, after



θ
1



 is solved,



T



1
0



 can be cancelled to allow the robot model to reduce a joint angle and become a new model. At that time, selective solving can be performed in all of the sub-problems.Basic problems 3.2.1 and 3.2.3 can be solved using the same formula solution. In the following paragraphs, basic problem 3.4.1 will be used for the description.Therefore, there exist two types of basic problems in the first type of sub-problem. This section gives the corresponding relevant existence conditions and formula solutions. 3.3. Solving the Second Type of Sub-ProblemSince the rotational component only provides three independent equations, a maximum of three unknowns can be solved. First, the rotational matrix Rotx(

θ

) is introduced. Rotx(

θ

) represents a

θ

 radian rotation around the X-coordinate axis. Similarly, Rotz(

θ

) and Roty(

θ

) represent rotations around the Y- and Z-axes. The Euler angle theorem indicates that a generic rotation matrix can be obtained by composing a suitable sequence of three rotations while guaranteeing that two successive rotations are not made around parallel axes [18]. Therefore, any rotational matrix R can be expressed as Rotz(

φ

), Roty(

ϑ

), and Rotz(

ψ

).The DH parameters of a serial robot with a certain DOF are shown in Table 4.According to the forward kinematics formula,









R



3
0

=
Rotz

(


θ
1


)

Rotx

(


α
1


)

Rotz

(


θ
2


)

Rotx

(


α
2


)

Rotz

(


θ
3


)

Rotx

(


α
3


)

,







R



3
0

=
Rotz

(


θ
1


)

Roty

(


θ
2


)

Rotz

(


θ
3


)

.








(28)

A serial robot has three continuous joints meeting



α
1

=
−

π
2

,

α
2

=

π
2


 
and
 


α
3

=
0


, whose rotational components



R



3
0



 are known, two sets of solutions can be found using Euler’s formula. 3.3.1. Three Mutually Perpendicular Sub-ChainsBased on

α

 in the DH parameters, the conclusions in Section 2.4 can be used to simplify the sub-chains and obtain the expression of the rotational matrix,






R



3
0

=

[





c
o
s

θ


s
1



c
o
s

θ


s
2



c
o
s

θ


s
3



+

n


s
1

e



n


s
2

e


s
i
n

θ


s
1



s
i
n

θ


s
3








n


s
1

e



n


s
2

e


s
i
n

θ


s
1



c
o
s

θ


s
3



−
c
o
s

θ


s
1



c
o
s

θ


s
2



s
i
n

θ


s
3








n


s
2

e


c
o
s

θ


s
1



s
i
n

θ


s
2









s
i
n

θ


s
1



c
o
s

θ


s
2



c
o
s

θ


s
3



−

n


s
1

e



n


s
2

e


c
o
s

θ


s
1



s
i
n

θ


s
3







−

n


s
1

e



n


s
2

e


c
o
s

θ


s
1



c
o
s

θ


s
3



−
s
i
n

θ


s
1



c
o
s

θ


s
2



s
i
n

θ


s
3








n


s
2

e


s
i
n

θ


s
1



s
i
n

θ


s
2










n


s
1

e


s
i
n

θ


s
2



c
o
s

θ


s
3







−

n


s
1

e


s
i
n

θ


s
2



s
i
n

θ


s
3







−

n


s
1

e



n


s
2

e


c
o
s

θ


s
2








]

,





(29)


for which the following expressions can be obtained:





{






θ


s
1



=
atan
2

(


n


s
2

e



r

23


,

n


s
2

e



r

13



)








θ


s
2



=
atan
2

(




r

13




2

+

r

23




2



,
−

n


s
1

e



n


s
2

e



r

33



)








θ


s
3



=
atan
2

(

−

n


s
1

e



r

32


,

n


s
1

e



r

31



)







,





(30a)


or






{






θ


s
1



=
atan
2

(

−

n


s
2

e



r

23


,
−

n


s
2

e



r

13



)








θ


s
2



=
atan
2

(

−



r

13




2

+

r

23




2



,
−

n


s
1

e



n


s
2

e



r

33



)








θ


s
3



=
atan
2

(


n


s
1

e



r

32


,
−

n


s
1

e



r

31



)







,





(30b)


where



θ


s
k





 represents the sum of the rotation angles of the

k

th sub-chain of the robot and



n


s
k

e




 represents the symbol of the last linkage

α

 in the


k
th


 sub-chain.



r

x
y




 represents the element at the position of the

x

th row and the

y

th column of the rotation matrix



R



3
0



. The problem of solving the sum of the rotation angles of three mutually perpendicular sub-chains is referred to as basic problem 3.3.1. 3.3.2. Two Mutually Perpendicular Sub-ChainsSimilarly, when there are only two mutually perpendicular sub-chains, the expression of the rotational component at that time is as follows:





R



2
0

=

[





c
o
s

θ


s
1



c
o
s

θ


s
2







−
c
o
s

θ


s
1



s
i
n

θ


s
2








n


s
1

e


s
i
n

θ


s
1









s
i
n

θ


s
1



c
o
s

θ


s
2







−
s
i
n

θ


s
1



s
i
n

θ


s
2







−

n


s
1

e


c
o
s

θ


s
1










n


s
1

e


s
i
n

θ


s
2








n


s
1

e


c
o
s

θ


s
2






0




]

,





(31)


with the corresponding solution:





{






θ


s
2



=
atan
2

(


n


s
1

e



r

31


,

n


s
1

e



r

33



)








θ


s
1



=
atan
2

(




r

21




c
o
s

θ


s
2





,



r

11




c
o
s

θ


s
2






)







.





(32)





r

x
y




 represents the element at the position of the

x

th row and the

y

th column of the rotation matrix



R



2
0



. The problem of solving the sum of the rotational degrees of two mutually perpendicular sub-chains is referred to as basic problem 3.3.2. 3.4. The Third Type of Sub-ProblemBefore the second type of sub-problem is employed by the governing algorithm, the DOF of the robot at that time is

i

, then the number of DOFs with


α
=
0


 in the first


i
−
1


 DOFs is

p

. If


p
≠
0


, not all joint angles are obtained by the second type of sub-problem. In this case, the translational component needs to be employed to solve for the remaining joint angles. Such problems are called the third type of sub-problem.For any of this type of sub-problem, when the first chain only has one joint, the forward kinematics formula can be directly used to simplify the robotic model. Based on that and according to Equation (4), the translational components of a robot with a DOF of

i

 can be divided into

i

 components. Since the second type of sub-problem can solve the sum of the rotational angles of the sub-chains of the robot, based on Equation (17), the translational equation can be arranged as






P



i
0

−

P


θ


s
1





−

R


θ


s
1






P


θ


s
2





−

R


θ


s
1






R


θ


s
2






P


θ


s
3





=

∑

n
=
1


n
=
i



P



n

n
−
1


−

P


θ


s
1





−

R


θ


s
1






P


θ


s
2





−

R


θ


s
1






R


θ


s
2






P


θ


s
3





.





(33)





P


θ


s
k







 and



P


θ


s
k







 represent the rotational and translational components of the

k

th sub-chain, which is defined by the formula (11) and formula (12). All terms on the left side of Equation (33) are known and are written as


P
^


 in the following paragraphs. Conversely, there are unknown quantities on the right side of the equation. Since the third type of problem has a maximum of three sections of sub-chains,



[


s
1

,

s
2

,

s
3


]



 is used to represent the length of each sub-chain on the right side of the equation. Depending on the length of each sub-chain, the appropriate formula solutions are presented with



s
i

t


 representing the

t

th joint in the

i

th section of the sub-chain.As an example, for



z
1

∥

z
2

⊥

z
3

∥

z
4



, there exist two sub-chains,



s
1


 
and
 


s
2



, either of which has a sub-chain length of two. After the second type of sub-problem is solved, the length of each sub-chain decreases by one. For example, the length of each sub-chain on the right side of Equation (33) is



[

1
,
1
,
0

]



.All possible cases will be analyzed and solved for in the following cases. 3.4.1. Sub-Chain Length as [1,0,0]








θ


s
1

1


=
a
t
a
n
2

(


a


s
1

1




P
^

y

,

a


s
1

1




P
^

x


)

.







θ


s
1

2


=



[


θ


s
1



−

θ


s
1

1



]



±
π


.








(34)

 3.4.2. Sub-Chain Length as [2,0,0]








θ


s
1

11


,

θ


s
1

12


=

F
2


(

A
,
B
,
C

)

,
 
where
 

{





A
=


P
^

x







B
=


P
^

y







C
=




P
^

x



2

+


P
^

y



2

+

a


s
1

1




2

−

a


s
1

2




2



2

a


s
1

1










.







θ


s
1

1


+

θ


s
1

2


=

F
1


(

D
,
L
,



P
x


˜

,



P
y


˜


)

,
 
where
 

{








P
x


˜

=


P
^

x

−

a


s
1

1


cos

θ


s
1

1











P
y


˜

=


P
^

y

−

a


s
1

1


sin

θ


s
1

1








L
=

a


s
1

2








D
=
0













θ


s
1

2


=
f



[


(


θ


s
1

1


+

θ


s
1

2



)

−

θ


s
1

1



]



±
π









θ


s
1

3


=
f



[


θ


s
1



−

(


θ


s
1

1


+

θ


s
1

2



)


]



±
π










(35)

 3.4.3. Sub-Chain Length as [2,1,0] and [1,1,0]





θ


s
2

11


,

θ


s
2

12


=

F
2


(

A
,
B
,
C

)

,
 
where
 

{





A
=
0






B
=

n


s
1

e



a


s
2

1








C
=


P
^

z

−

d


s
1

1


−

d


s
1

2








.





(36a)







θ


s
2

2


=
f



[


θ


s
1



−

θ


s
1

1



]



±
π


.





(36b)







P
^

−

R


s
1




P


s
2

1


=

P


s
1

1


+

R


s
k

1



P


s
k

2


.





(36c)





R


s
k

t




 and



P


s
k

t




 represent the rotational and translational components of the

t

th joint in the

k

th section of the sub-chain. According to Equations (36a) and (36b), all joint angles in the sub-chain



s
2



 can be solved. Moreover, according to Equation (36c), the first sub-chain solving problem is transformed into either basic problem 3.6.1 or basic problem 3.6.2. 3.4.4. Sub-Chain Length as [1,2,0]





θ


s
1

11


,

θ


s
1

12


=

F
2


(

A
,
B
,
C

)

,

 
where
 


{





A
=

n


s
1

2



a


s
1

2


sin

θ


s
1









B
=
−

n


s
1

2



a


s
2

1


sin

θ


s
1









C
=



(


R


s
1





T

 

P
^


)


z

−

d


s
2

1


−

d


s
2

2








.





(37a)







θ


s
1

2


=
f



[


θ


s
1



−

θ


s
1

1



]



±
π


.





(37b)







R


s
1





T


(


P
^

−

P


s
1

1



)

=

P


s
2

1


+

R


s
2

1



P


s
2

2


.





(37c)

According to Equations (37a) and (37b), we could solve all joint angles in the sub-chain



s
1



. According to Equation (37c), the second sub-chain solving problem can be transformed into basic problem 3.4.2. 3.4.5. Sub-Chain Length as [2,0,1] or [1,0,1]





θ


s
3

11


,

θ


s
3

12


=

F
2


(

A
,
B
,
C

)

,

 
where
 


{





A
=
0






B
=

n


s
1

e



a


s
3

1


s
i
n

θ


s
3









C
=


P
^

z

−

d


s
1

1


−

d


s
1

2


+

n


s
1

3



n


s
2

1



d


s
3

1


c
o
s

θ


s
3









.





(38a)







θ


s
3

2


=
f



[


θ


s
3



−

θ


s
3

1



]



±
π


.





(38b)







P
^

−

R


s
1




R


s
2




P


s
3

2


=

P


s
2

1


+

R


s
2

1



P


s
2

2


.





(38c)

According to Equations (38a) and (38b), all joint angles in the sub-chain



s
3



 can be solved. According to Equation (38c), the first sub-chain solving problem can be transformed into either basic problem 3.4.2 or basic problem 3.4.1. 3.4.6. Sub-Chain Length as [1,0,2]





θ


s
1

21


,

θ


s
1

22


=

F
2


(

A
,
B
,
C

)

,

 
where
 


{





A
=
0






B
=

n


s
2

1



a


s
1

1


s
i
n

θ


s
2









C
=


(

R


s
2





T


R


s
1





T


P
^

)

z

−

d


s
3

1


−

d


s
3

2


+

n


s
1

2



n


s
2

1



d


s
1

1


c
o
s

θ


s
2









.





(39a)







θ


s
1

1


=
f



[


θ


s
1



−

θ


s
1

2



]



±
π


.





(39b)







R


s
2





T


R


s
1





T


P
^

−

R


s
2





T


R


s
1





T


P


s
1

1


=

P


s
3

1


+

R


s
3

1



P


s
3

2


.





(39c)

According to Equations (39a) and (39b), we could solve all joint angles in the sub-chain



s
1



. According to Equation (39c), the third sub-chain solving problem can be transformed into basic problem 3.4.2.In the case of [1,1,1], it may be impossible to find a closed-form solution due to the high complexity of the equation. Therefore, the third type of sub-problem has six basic problems. 3.5. SummaryThe above-mentioned content proposed the two decoupling methods of series robots firstly. Three types of sub-problems are proposed through these two decoupling methods. Ten basic problems were derived through analyzing the solvable condition and solution method of each type of sub-problems specifically. If a series robot can be described through the three types of sub-problem based on these ten basic problems, the robot must be a closed inverse solution.

P

 represents the number of the DOF with


α
=
0


 in the first


i
−
1


 DOFs, i.e., the number of


α
=
0


 in the first


i
−
1


 rows of the DH parameter table.In the case of


i
−
P
>
3


, it means that there are more vertical joints in the robot. There will be more than three unknown numbers that cannot be solved in the rotational component. If there is a closed solution, a low-order trigonometric function equation can only be solved through translation components. There are two basic problems that are feasible. The restrictions and solution formula of the two basic problems is shown in Table 5.In the case of


i
−
P
<
3


, it means that there are more parallel joints in the robot. There will be less than three unknown numbers in the rotational component, then, the unknown number can be solved through in the rotational component directly. The parallel joints in the rotation component may be an independent joint angle or the sum of the rotation angles of the sub-chains; therefore, they can be represented as unknown number here. In the case of


i
−
P
=
3


, the formula (30) can be used to solve the three-unknown number. In the case of


i
−
P
=
2


, the formula (32) can be used to solve the two-unknown number. In the case of


i
−
P
=
1


, the first formula in the formula (32) can be used to solve the only unknown number.If all joint angles are not solved after using the second sub-problems, it indicates that there is long sub-chain in the translational component. At this time, the remaining joint angles need to be solved by combing the third sub-problems with the result of the second sub-problems. The six basic problems in the third sub-problems are shown in Table 6.Since the third type of problem has a maximum of three sections of sub-chains,



[


s
1

,

s
2

,

s
3


]



 is used to represent the length of each sub-chain on the right side of the equation. Depending on the length of each sub-chain, the appropriate formula solutions are presented with



s
k

t


 representing the

t

th joint in the

k

th section of the sub-chain. 4. Algorithm Design for Universal Inverse KinematicsThe translational and rotational components of a serial robot with a closed-form solution are mutually decoupled. Therefore, the partial joint angles of the robot can be solved based on the first or second type of sub-problem. This simplifies the original robot model into a new robot model. If the new robot model has a closed-form solution, the solution will definitely continue along one of the three types of sub-problems until all the problems are solved. Therefore, the process of solving the closed-form inverse solution of a serial robot can be completed via constant model simplification. The logical flow chart of the entire algorithm is shown in Figure 2.In Figure 2,

P

 represents the number of the DOF with


α
=
0


 in the first


i
−
1


 DOFs, i.e., the number of


α
=
0


 in the first


i
−
1


 rows of the DH parameter table.The inverse kinematics problem has multiple solutions. Nonetheless, the selection of these solutions necessitates a relevant upper logic design. In addition, changes in the robotic joints must be continuous:




a
r
g
 



m
i
n

k




∑

i
=
1

6



|


θ

i
,
c
u
r


−

θ

i
,
k



|

.





(40)

In cases where the robot is in a stationary state, the joint angle of the

k

 set can be first solved and then Equation (40) can be used to determine the inverse motion index value corresponding to the current position.The main purpose of this paper was to find a more complete inverse solution judgment condition, which is more accurate and specific than the Pieper principle. The general inverse solution algorithm designed based on this judgment condition is also directed to a series robot with a closed inverse solution. For this paper purposed ten basic problems, which means a series of robots with closed inverse solutions can be obtained through combining the basic problems. For example, although



z
1

∥

z
2

⊥

z
3

∥

z
4
a

⊥

z
5

a
,
d


⊥

z
6



, or



z
1

∥

z
2

⊥

z
3

∥

z
4

∥

z
5

∥

z
6



 are not common, but it is indeed that there are robots with a closed inverse solution. In addition, maintaining the robot configuration does not change, only the direction of rotation and the positive or negative of the offset are changed, the algorithm can still calculate correctly. This can provide great convenience for the application of an engineer. Finally, the logical design of the algorithm is complete. This means that once you use a situation other than ten basic questions to design the robot, the algorithm will jump out and terminate. Therefore, the algorithm is not to solve the inverse solution problem of any robot, but to judge whether the closed inverse solution exists and to solve it. 5. ExperimentsThe previous section discussed the design of the universal inverse kinematics solution algorithm. In this section, four of the experiments will be carried out to verify the completeness, versatility, stability, and real-time performance of the algorithm.Frist of all, the algorithm was implemented in MATLAB 2016b on a 64-bit Windows 10 operating system. The completeness, versatility and stability of the algorithm will be verified in MATLAB. Subsequently, the algorithm was performed using the Beckhoff-C6920 controller. We built a six-DOF KingKong robot using the Kollmorgen RGM motor for the real-time testing. 5.1. Verification Experiment for Algorithm CompletenessFirstly, the algorithm designed in this paper was logically complete. The first simulation experiment would test the completeness of the algorithm. Here, a robot with three parallel joints was selected as the experimental object. The DH parameter of it is shown in the Table 7. This robot is a common series robot, but it cannot be described by a single sub-problem.First, the algorithm receives the DH parameters of the robot. Algorithm will enter in the second type of sub-problem to solve the rotation angle and



θ


s
1





 of the sub-chain



s
1



. The length of the sub-chain was



[

2
,
0
,
0

]



 after been simplified and calculated, therefore, the remaining joint angles was solved by the basic problem 3.6.2 in the third type sub-problems.Consequently, the initial position was


Θ
=

[





90
°






90
°






45
°





]



, and the end posture was:





[





−
0.7071




0.7071



0



−
0.0121






−
0.7071




−
0.7071



0



−
0.1121





0


0


1



0.3





0


0


0


1




]

.





(41)

All joint angles were solved with the algorithm, as shown in Table 8.It is easy to verify that the two sets of joint angles are correct.A robot with four parallel joints was now used as the experimental object. Its DH parameters are shown in Table 9.The algorithm will enter in the second type of sub-problem the solve the rotation angle and



θ


s
1





 of the sub-chain



s
1



. The length of the sub-chain was [3,0,0] after being simplified and calculated, the algorithm was ended for it was not in the basic problem of the third type sub-problems. In fact, there are only three valid equations for series robots with four-degree-of-freedom, which is impossible to solve its inverse motion problem.Experiment 5.1 verified the completeness of the algorithm by two examples. The first example was a three-parallel joint robot, the correct joint angles were obtained through an algorithm. Then, we used a four-parallel joint robot to test, and the algorithm was terminated for it was not in the basic problems. This shows that the algorithm would exit correctly when it encounters an unsolvable problem, and it will be able to calculate the result when it encounters a solvable problem.This experiment also proved that the proposed judgment method could be used to low-degree-of-freedom robots. In addition, when there were four adjacent parallel joints in a six-degree-of-freedom robot, the Pieper criterion was satisfied, but the proposed algorithm could judge that the robot did not have a closed inverse solution. This complements the shortcomings of the Pieper criterion. 5.2. Verification Experiment of Algorithm VersatilityThe proposed algorithm could solve those serial robots that could be described by three types of sub-problems. Since the description of the ten basic problems was determined, a series robot with a closed-form inverse solution could be constructed based on ten basic problems. Two uncommon robots were used as examples to verify the versatility of the algorithm in this experiment.We constructed a robot


B
o

t
1



, whose structure was



z
1

∥

z
2

⊥

z
3

∥

z
4
a

⊥

z
5

a
,
d


⊥

z
6



 based on basic problem 3.4.2 and 3.5.1. Its DH parameters are shown in Table 10.The robot had three vertical joints, so the decoupling of the end was carried out firstly. Then, we found that



z
1

∥

z
2

⊥

z
3

∥

z
4
a

⊥

z
5

a
,
d




 could be solved by the basic problem 3.2.2. When the first three joint angles were solved, the simplified robot



z
4
a

⊥

z
5

a
,
d


⊥

z
6



 could be solved by the second type of sub-problems.Consequently, the initial position was


Θ
=

[





90
°






60
°






60
°






60
°






30
°






30
°





]



, and the end posture was:





[





0.5625




0.1752




0.8080




−
0.0228






−
0.8248




0.1875




0.5335




0.6441






−
0.0580




−
0.9665




0.2500




0.7192





0


0


0


1




]

.





(42)

All joint angles were solved with an algorithm, as shown in Table 11.It is easy to verify that the four sets of joint angles are correct. Then, we kept the configuration of the robot unchanged and modified the positive direction of the rotation of the robot joint, the positive and negative of

a

 and the value of

d

. This was used to verify whether the algorithm could cope with parameter changes. The changed DH parameters are shown in Table 12.Consequently, the initial position was


Θ
=

[





90
°






60
°






60
°






60
°






30
°






30
°





]



, and the end posture was:





[





0.5625




−
0.8248




0.0580




−
0.2036






0.1752




0.1875




0.9665




−
0.1825






−
0.8080




−
0.5335




0.2500




 
0.4192





0


0


0


1




]

.





(43)

All joint angles were computed with the algorithm, as shown in Table 13It is easy to verify that the four sets of joint angles are correct.We constructed the robot


B
o

t
2



, whose structure was



z
1

∥

z
2

⊥

z
3

∥

z
4

∥

z
5

∥

z
6



 based on basic problem 3.5.1 and 3.6.6. Its DH parameters are shown in Table 14.The robot had three sub-chains, and the second type of sub-problem was firstly used to obtain the sum of the rotation angle of the three segments. Then, algorithm turned into the third type sub-problems for there were joint angles that had not been solved. In the third sub-problem, we could use the basic problem 3.6.6 to solve, and then solve all joint angles.Consequently, the initial position was


Θ
=

[





90
°






60
°






60
°






45
°






45
°






45
°





]



, and the end posture was:





[





−
0.0474




0.6597




−
0.7500




−
0.9344






−
0.7891




0.4356




0.4330




0.2573






0.6124




0.6124




0.5000




−
0.0017





0


0


0


1




]

.





(44)

All joint angles were solved with the algorithm, as shown in Table 15.It is easy to verify that the four sets of joint angles are correct.In this group of experiments, the test subjects were two uncommon robots constructed by basic questions. However, according to the proposed theory, these two robots had a closed inverse solution. In the experiment, the inverse solution of both robots was solved correctly. In addition, for the first robot, its configuration remains unchanged, but the link parameters were greatly modified, the correct result was obtained in the end. It could be seen that the algorithm had good versatility. As long as a given robot can be described by three sub-problems, its closed-from solution can be obtained whether it is in low degree of freedom or six degrees of freedom. At the same time, for the robot with the same configuration, the change of the link parameters does not affect the inverse kinematics solution. 5.3. Verification Experiment for the Algorithm ContinuityThis experiment would use the common Puma560 as the subject. In the experiment, the robot should move according to the specified trajectory. We needed to observe whether the joint angle after the inverse solution was continuous when solving the continuous space trajectory. This is important in the actual movement of robot. If there is a jump or discontinuity in the joint space curve, it will cause great impact to the motor, and the curve of the end also does not move according to the specified trajectory. The DH parameters of the Puma560 robot are shown in Table 16.The quantity of the vertical joints was judged following the input of the algorithm into the DH model of the Puma560 robot. Subsequently, the algorithm entered the first type of sub-problem. Then, joint decoupling was performed for



J
6



 and



J
1

⊥

J
2

∥

J
3

⊥

J

4
,
a


⊥

J

5
,
a
,
d




. Based on basic problem 3.4.1, the angle value of



θ
1



 was obtained. In addition, after



θ
1



 was obtained,



T



6
1



 was obtained using to the forward kinematics formula. After it was simplified,



J
2

∥

J
3

⊥

J

4
,
a


⊥

J

5
,
a
,
d


⊥

J
6



 formed a new robot model and was substituted into the algorithm. Similarly,



J
2

∥

J
3

⊥

J

4
,
a


⊥

J

5
,
a
,
d




 was solved using basic problem 3.2.2 and



θ
2


 
and
 


θ
3



 were subsequently obtained. After the reduction in the DH parameters and the transformational matrices,



T



6
4



 and the robot model



J

4
,
a


⊥

J

5
,
a
,
d


⊥

J
6



 were substituted into the algorithm to solve the rational component in the second type of sub-problem. All joint angles were solved at that time.Consequently, the initial position was


Θ
=

[





25.5667
°






−
0.0624
°






3.0736
°






−
25.5975
°






87.2840
°






1.3005
°





]



, and the end execution posture was:





[




0


0



−
1




0.4521





0


1


0



0.0499





1


0


0



0.4318





0


0


0


1




]

.





(45)

All joint angles were computed with the algorithm, as shown in Table 17.Here we also used the kinematic inverse function in the Robotics Toolbox, and could also find eight groups of solutions, as shown in Table 18. It could be seen that part of the joint angles have exceeded the scope of



[





−
π



π




]



. The reason is that there was no uniform inverse trigonometric function selected in the Robotics Toolbox. In actual use, for example, the Beckhoff-C6920 controller and the Kollmorgen RGM motor, both use real numbers to describe the motion of the motor rather than a positive real number. Therefore, the method proposed in this paper had certain advantages from this point of view.The robot was instructed to move as per the Equation (51) spiral line with a step size of 0.01:





{





x
=
0.3
t






y
=
0.2
c
o
s

(

2
π
t

)

−
0.2






z
=
0.2
s
i
n

(

2
π
t

)







,
t
∈

[

0
,
1

]

.





(46)

According to formula (40), with the fifth set of solutions selected. According to the joint angle, the end position was recomputed with the motion trajectory shown in Figure 3. The joint angle was inversely solved as per the end trajectory to obtain the continuous joint position, as shown in Figure 4.As shown in Table 17, the algorithm could solve for multiple sets of joint angles, and it could be confirmed via positive kinematics that all the joint angles were correct. In addition, in the planning experiment of the Cartesian space trajectory, the joint angle inversely solved according to the target trajectory is shown in Figure 4 and its curve changed continuously without jumps. In Figure 3, the end trajectory was recalculated from the obtained joint angle and was consistent with the planned trajectory. This proved that the algorithm could correctly solve the inverse kinematics of the spatial trajectory. 5.4. Real-Time Verification Experiment of the AlgorithmIn the industry, the robot controller sends position information to the motor driver in a certain cycle, the shorter the cycle, the better the real-time performance. For some occasions with high precision, if the cycle is too long, a big error will occur in the outline of the end. In addition, if the desired end trajectory is constantly changing, the controller is also required to be able to react and plan quickly during the cycle. Therefore, real-time performance is an important performance indicator in the robot controlling field. In order to improve the closed-loop period of the system, in addition to the purchase of more powerful hardware devices, the more important factor is the operation speed of algorithm. Therefore, this paper designed a verification experiment whose real-time performance was closed to prove that the algorithm proposed in this paper was not only accurate but also efficient and fast.The six-DOF KingKong robot built with a Beckhoff-C6920 controller and a Kollmorgen RGM motor was used in the experiment testing the correctness and real-time performance of the algorithm. The DH parameters of the robot are listed in Table 3. The C6920 controller in Figure 5. The C6920 controller used a 32-bit Windows 7 operating system and was equipped with an Intel Core i5 processor.Figure 6 displays the control framework for the entire system. When the controller received the order of motion, the critical parameters of the locus equation were computed according to the order. Subsequently, the position point at the next time point was planned in the Cartesian spatial planner. Based on the position points in Cartesian space, the inverse kinematics solving method proposed here was employed to obtain the position to be reached by each motor at the next time point. The closed-loop circle of the motor controller was 2 ms. The controller sent the motion order to the RGM motor via CanOpen. CanOpen is a high-level communication protocol based on the Controller Area Network. It is often used in embedded systems and is a type of field bus commonly used in industrial control.The number of vertical joints was judged according to the KingKong DH model. Then, the algorithm assessed the first type of sub-problem. After joint decoupling was performed for



J
6



,



J
1

⊥

J
2

∥

J
3

∥

J
4

⊥

J

5
,
a




 was able to solve for



θ
1



 using basic problem 3.2.1. After



θ
1



 was obtained,



T



6
1



 and



J
2

∥

J
3

∥

J
4

⊥

J

5
,
a


⊥

J
6



 were obtained using the forward kinematics formula. At the time, the robot belonged to the second type of sub-problem and we could directly solve for



θ
2

+

θ
3

+

θ
4

,

θ
5


 
and
 


θ
6



. Subsequently, basic problem 3.4.2 was used to solve for



θ
2


 
and
 


θ
2

+

θ
3



 and to obtain



θ
3



 and



θ
4



.In this experiment, the robot would be commanded to move according to the specified spatial trajectory in the real environment, and the acceleration process of the motor must be considered. A common acceleration planning method is a seven-segment S curve. This method uses the square wave Jerk curve as the input of the system, and the acceleration, velocity, and position quantities obtained through the integrating of time, as is shown Figure 7.It can be seen from the figure that the acceleration curve of the seven-segment S-curve constructed by square wave Jerk input is a linear piecewise function. Although it is continuous, but there are a finite number of non-conductible breakpoints. If the acceleration can be made to have higher order differentiable properties, the robot movement can be smoother.In the Descartes spatial planner of the controller, the 15-segment S-curve spatial trajectory planning method was used. When the objective position,

S

, and the maximum values of the curve,



S
˙

,

S
¨

,

 
and
 


S
⃛



, are given, this method can provide a smooth curve and the speed utilization rate can approximate the optimal solution. In 15-segment S planning, the jerk input uses the sine piecewise function Equation (52) to replace the jerk square wave input in the traditional seven-segment S curve. A schematic diagram for the 15-segment S curve is shown in Figure 8.Compared with the traditional seven-segment S curve, the 15-segment curve proposed in this paper was constructed by sinusoidal function. We know that sinusoidal functions have infinite differentiable properties. Therefore, the acceleration curve of the 15-segment S curve also has infinite differentiable properties. The curve obtained by this planning method is smoother.






h
n


(
t
)

=

{





s
i
n

π
2

n
t




x
∈

[

0
,

1
n


]






1



x
∈

[


1
n

,

1
n

+
m

]







c
o
s

π
2

n

(

t
−
m

)





x
∈

[


1
n

+
m
,

2
n

+
m

]







.





(47)

In Equation (47),

n

 is an adjustable parameter to adjust the rising speed of the jerk curve and

m

 depends on the maximum values of



S
¨


 
and
 


S
⃛



.The initial position of the KingKong robot was


Θ
=

[





0
°






−
60
°






120
°






−
135
°






−
45
°






−
45
°





]



, as shown in Figure 9.At that time, based on the forward kinematics computation, the end posture was:





[





−
0.5536




0.8124




0.1830




−
0.4961






0.5000




0.5000




−
0.7071




−
0.1330






−
0.6660




−
0.3000




−
0.6830




0.0895





0


0


0


1




]

.





(48)

The algorithm was used to obtain the inverse solution and eight sets of joint angles, as shown in Table 19. According to formula (40) the fourth set of solutions was selected and applied in the motion control logic.The spatial planning was as follows. The experiment used a spiral line as the expected end trajectory. The parameter equation of the end trajectory spiral line is:





{





x
=
0.15
cos

(

2
π
t

)

−
0.15






y
=
0.15
sin

(

π
t

)







z
=
0.05
t




,
t
∈

[

0
,
5

]



.





(49)

First, according to Equation (50), the arc length of the spiral line is:




l
=


∫

0
5






(



d
x


d
t



)


2

+



(



d
y


d
t



)


2

+



(



d
z


d
t



)


2



d
t
=
2.3694
 
m
.





(50)

Given




S
˙


m
a
x


=
0.125

 
m

/
s


,





S
¨



m
a
x


=
0.025

 
m

/
s


,




S
⃛


m
a
x


=
0.01

 
m

/
s
,


 and


n
=
1


, the 15-segment S curve was used to plan the end arc length. The total time consumed was 28.1821 s. The variation curve at each stage of the trajectory is shown in Figure 10.The arc length obtained according to Equation (50) was used to rewrite the parametric equation:





{





x
=
0.15
cos

(


l

0.1581



)

−
0.15






y
=
0.15
sin

(


l

0.1581



)







z
=
0.1581
 
l




,
l
∈

[

0
,
l

]



.





(51)

In summary, the position curve in Cartesian space and its various derivatives could be obtained, together with the planned position curves of each joint and their various derivatives, as shown in Figure 11, Figure 12, Figure 13, Figure 14, Figure 15 and Figure 16.Figure 17 shows the position after the robot has finished its run. The curve of the actual motion of the robot in Cartesian space was calculated from the forward kinematics and is shown together with the planned spatial curve in Figure 18. After the run was completed, the actual motion curve of each joint was acquired from the controller, as shown in Figure 19.In the fourth experiment, the Beckhoff controller, which is commonly used in the industry, was used and the general algorithm was implemented in the controller. The robot controller sends motion commands to the drive at a certain period. This requires the controller to complete the kinematic inverse solution within a specified amount of time to ensure the continuity. A shorter period results in a higher real-time performance. The period used in this article was 2 ms. The 2 ms cycle is sufficient to meet the general accuracy requirements. For example, in Ref. [5] the medical robot can accept a closed loop period of 20 ms. In other words, the proposed algorithm in this paper could achieve a closed-loop period higher than industrial demand in equipment commonly used in the industry. The fast closed-loop period means that the algorithm has higher computational efficiency.Since our algorithm could decompose complex inverse motion problems into several sub-problems and solve them one by one, all joint angles could be solved accurately and quickly. The final experimental results show that the system could complete the inverse solution of the kinematics within the specified period. This allows the algorithm to run stably in situations with real-time requirements.Figure 8 shows the end curve planned to use 15 S-curve segments. The apparent rise and fall process in the jerk curve could be seen. This allows the entire curve to have a smoother transition at start–stop. Based on Equation (46) and the plan in Figure 10, the angular curve of each joint could be obtained, as shown in Figure 11, Figure 12, Figure 13, Figure 14, Figure 15 and Figure 16.It can be seen from Figure 11, Figure 12, Figure 13, Figure 14, Figure 15 and Figure 16 that all joint motion curves, as well as the various derivative curves could be ensured to start from 0 during the start-up phase smoothly. The continuous and smooth was kept in the whole moving process. Moreover, the curve was smoothly reduced to zero during the stop phase. Especially the fourth derivative had kept the continuous and smooth fluctuations, which was the effect that could not be realized through traditional planning method. This paper introduced the joint curve obtained through using the traditional seven-segment planning there to facilitate the comparison, as shown in Figure 20, Figure 21, Figure 22, Figure 23, Figure 24 and Figure 25. It can be clearly seen that the Jerk curve of each joint had an obvious jump phenomenon during the start–stop phase. Meanwhile, thumbing changes occurred in the operation process. These problems would cause the motor to operate unstably in the end.Figure 18 shows the actual run in Cartesian space. It could be seen that the actual motion trajectory coincided with the planned motion trajectory. The mean square error of the two tracks was calculated to be 7.8265 × 10−10 m. This data shows that the error between the actual trajectory and the target trajectory was extremely small. This shows that the inverse solution of the robot had higher accuracy. 6. ConclusionsBased on the DH model, this study proposed a universal algorithm for finding an inverse kinematics closed-form solution. This algorithm divided the inverse kinematics problem related to robots with a closed-form solution into three sub-problems assuming that the algebraic equation had a formula solution. The solvability conditions for the three types of sub-problems were analyzed to derive a formula solution. If a serial robot can be described with these three types of sub-problems, the robot will definitely have a closed-form solution. Meanwhile, the formula solution based on such a problem could quickly solve for all the joint angles. This method was not only applicable to six-DOF robots with a closed-form solution but also to low-DOF robots with the same solution form. In addition, establishing an algorithm based on the DH model provides a concise and efficient tool for selecting sub-problems and a real-time inverse kinematics solution for the motion controller of a serial robot. To verify the correctness and real-time performance of the algorithm, we presented four experimental designs. The first three experiments were conducted on MATLAB with a series of robot to verify the completeness, universality, and continuity of this algorithm.In the first experiment, the completeness of the algorithm was verified. The experiment used a low-degree-of-freedom robot with closed inverse solutions to prove that the algorithm could solve its closed inverse solution, and the algorithm would be terminated for the robot without closed inverse solutions to avoid infinite loop. This was used to prove the completeness of the algorithm. In the second experiment, two uncommon robots were constructed through using some basic problems, but the closed inverse solution could still be solved. Therefore, it could be known that the closed inverse solution of the series robots constructed by basic problems could be solved. Meanwhile, for these robots whose structure was not changed but the link parameter was changed, the closed inverse solution of them could also be solved correctly, which indicates that the algorithm had certain versatility in solving the closed inverse solution problem. In the third experiment, the common Puma560 robot was used as the experimental object. In the experiment, a spatial curve was planned. The correct joint angle sequence was obtained and the changes of the joint angle curve were continuously without jumping after been inversely solved by the algorithm. Which indicates that the algorithm could guarantee the continuity of its mapping on the inverse solution problem.The fourth experiment was conducted on a six-DOF robotic platform built using a Beckhoff-C6920 controller and an RGM motor to verify the real-time performance of the algorithm using the above hardware platform. The spatial and joint positions were computed with a close-loop cycle of 2 ms and were transmitted to the motor via CanOpen. The results demonstrated the ability of the algorithm to solve the three sub-problems within a specified cycle and to compute the appropriate joint angles. Moreover, the curve was continuous. This paper used a completely new approach to study the inverse kinematics of serial robots. In this study, the conditions for the existence of the closed-form inverse kinematic solution of a serial robot were completed and the basic theory of robotics was perfected. Based on this method, a general closed-form inverse kinematics algorithm based on the DH model was implemented, which had not been done in previous studies. Importantly, this method is a general-purpose algorithm that can be used in industrial fields in real time. This increases the versatility of the universal serial robot motion controller.However, the algorithm still has shortcomings. First, the algorithm only targets serial robots and the moving joints are not included in the solution model. This limits the scope of application of the algorithm, due to its inability to solve the cases of SCARA robots or other parallel robots. In addition, the algorithm cannot solve the problem when the robot passes through a singular point; singular points are avoided via restrictions implemented in the software. Moreover, because the algorithm is a purely analytical method, it is difficult to combine with other numerical methods to solve the problem of singular points.
